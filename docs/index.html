<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Primary Meta Tags -->
  <title>
    Free Snapchat Memories Downloader - Save Before Snapchat Charges | No
    Upload Required
  </title>
  <meta name="title" content="Free Snapchat Memories Downloader - Save Before Snapchat Charges | No Upload Required" />
  <meta name="description"
    content="100% free tool to download all your Snapchat memories with metadata before Snapchat starts charging. No upload required - runs entirely in your browser. Free alternative to paid services. Preserve your photos, videos, and GPS data safely." />
  <meta name="keywords"
    content="snapchat memories downloader, free snapchat backup, save snapchat memories, snapchat charging for storage, free alternative, free exportsnaps, download snapchat photos, snapchat metadata, private snapchat downloader, local snapchat backup, snapchat memories free, browser-based snapchat downloader, no upload snapchat, preserve snapchat memories" />
  <meta name="author" content="andrefecto" />
  <meta name="robots" content="index, follow" />

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/" />
  <meta property="og:title" content="Free Snapchat Memories Downloader - Save Before Snapchat Charges" />
  <meta property="og:description"
    content="100% free tool to download all your Snapchat memories before they start charging. No upload required - completely private and runs in your browser. Free alternative to paid services." />
  <meta property="og:image" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/og-image.png" />

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image" />
  <meta property="twitter:url" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/" />
  <meta property="twitter:title" content="Free Snapchat Memories Downloader - Save Before Snapchat Charges" />
  <meta property="twitter:description"
    content="100% free tool to download all your Snapchat memories. No upload required - runs entirely in your browser. Save before Snapchat starts charging!" />
  <meta property="twitter:image" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/og-image.png" />

  <!-- Canonical URL -->
  <link rel="canonical" href="https://andrefecto.github.io/Snapchat-Memories-Downloader/" />

  <!-- Structured Data / JSON-LD -->
  <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "Snapchat Memories Downloader",
        "applicationCategory": "UtilityApplication",
        "operatingSystem": "Web Browser",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "Free tool to download all your Snapchat memories with metadata. No upload required - runs entirely in your browser. Save your photos and videos before Snapchat starts charging for storage.",
        "author": {
          "@type": "Person",
          "name": "andrefecto",
          "url": "https://github.com/andrefecto"
        },
        "aggregateRating": {
          "@type": "AggregateRating",
          "ratingValue": "5",
          "ratingCount": "1"
        }
      }
    </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
  <!-- FFmpeg.wasm for video processing -->
  <script src="ffmpeg/ffmpeg.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
    }

    h1 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 2.5em;
    }

    .subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 1.1em;
    }

    .warning {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin-bottom: 25px;
      border-radius: 4px;
    }

    .warning strong {
      color: #856404;
    }

    .upload-section {
      background: #f8f9fa;
      border: 2px dashed #dee2e6;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      margin-bottom: 25px;
      transition: all 0.3s;
    }

    .upload-section:hover {
      border-color: #667eea;
      background: #f0f2ff;
    }

    .upload-section.dragover {
      border-color: #667eea;
      background: #e8eaff;
    }

    input[type="file"] {
      display: none;
    }

    .btn {
      background: #667eea;
      color: white;
      padding: 12px 30px;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 600;
    }

    .btn:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .progress-container {
      display: none;
      margin-top: 25px;
    }

    .progress-bar {
      background: #e9ecef;
      border-radius: 10px;
      height: 30px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .progress-fill {
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      height: 100%;
      width: 0%;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 14px;
    }

    .status {
      color: #666;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .log {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-family: "Courier New", monospace;
      font-size: 13px;
      line-height: 1.4;
    }

    .log-entry {
      margin-bottom: 5px;
    }

    .log-entry.success {
      color: #28a745;
    }

    .log-entry.error {
      color: #dc3545;
    }

    .log-entry.info {
      color: #666;
    }

    .log-entry.warning {
      color: #ffc107;
    }

    .log-entry.ffmpeg {
      color: #6c757d;
      font-size: 12px;
    }

    .log-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
      border-bottom: 2px solid #dee2e6;
    }

    .log-tab {
      padding: 8px 16px;
      background: #f8f9fa;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: #666;
      transition: all 0.2s;
    }

    .log-tab:hover {
      background: #e9ecef;
      color: #333;
    }

    .log-tab.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
    }

    .log-content {
      display: none;
    }

    .log-content.active {
      display: block;
    }

    .features {
      margin-top: 40px;
      padding-top: 30px;
      border-top: 2px solid #e9ecef;
    }

    .features h2 {
      color: #667eea;
      margin-bottom: 15px;
    }

    .features ul {
      list-style: none;
      padding-left: 0;
    }

    .features li {
      padding: 8px 0;
      padding-left: 25px;
      position: relative;
    }

    .features li:before {
      content: "‚úì";
      position: absolute;
      left: 0;
      color: #28a745;
      font-weight: bold;
    }

    .footer-links {
      text-align: center;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #e9ecef;
    }

    .footer-links a {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
      margin: 0 10px;
    }

    .footer-links a:hover {
      text-decoration: underline;
    }

    .coffee-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #ffdd00;
      color: #000;
      padding: 10px 20px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      margin-top: 15px;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(255, 221, 0, 0.3);
    }

    .coffee-btn:hover {
      background: #ffed4e;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 221, 0, 0.4);
      text-decoration: none;
    }

    .github-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #24292e;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(36, 41, 46, 0.3);
    }

    .github-badge:hover {
      background: #2f363d;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(36, 41, 46, 0.4);
      text-decoration: none;
      color: white;
    }

    .info-box {
      background: #e7f3ff;
      border-left: 4px solid #667eea;
      padding: 20px;
      margin-bottom: 25px;
      border-radius: 4px;
    }

    .info-box h3 {
      margin-top: 0;
      color: #667eea;
    }

    .info-box ol {
      margin: 10px 0;
      padding-left: 25px;
    }

    .info-box li {
      margin: 8px 0;
    }

    .info-box a {
      color: #667eea;
      font-weight: 600;
    }

    .options-group {
      margin-top: 25px;
      padding-top: 20px;
      border-top: 1px solid #dee2e6;
    }

    .options-group-header {
      font-size: 18px;
      font-weight: 700;
      color: #667eea;
      margin-bottom: 15px;
    }

    details.collapsible {
      margin-top: 20px;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 15px;
      background: #f8f9fa;
    }

    details.collapsible summary {
      cursor: pointer;
      font-weight: 700;
      font-size: 16px;
      color: #667eea;
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    details.collapsible summary::-webkit-details-marker {
      display: none;
    }

    details.collapsible summary::after {
      content: '‚ñº';
      font-size: 12px;
      transition: transform 0.2s;
    }

    details.collapsible[open] summary::after {
      transform: rotate(180deg);
    }

    details.collapsible[open] {
      background: white;
    }

    .option-item {
      margin-top: 15px;
    }

    .option-item:first-child {
      margin-top: 0;
    }

    .option-label {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
    }

    .option-description {
      color: #666;
      font-size: 13px;
      margin-top: 5px;
      margin-left: 28px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="warning" style="background: #f8d7da; border-color: #dc3545; border-left: 4px solid #dc3545; margin-bottom: 20px;">
      <strong style="color: #721c24;">üö´ Important: Disable your adblocker for this site!</strong>
      <span style="color: #721c24;"> Adblockers may prevent downloads from working correctly.</span>
    </div>

    <h1>Free Snapchat Memories Downloader</h1>
    <p class="subtitle">
      Save ALL your Snapchat memories before they start charging for storage -
      100% FREE & Private
    </p>

    <div class="warning" style="background: #fff3cd; border-color: #ffc107">
      <strong>‚ö†Ô∏è Snapchat is Charging for Storage Soon!</strong> Download your
      memories now for FREE. Don't pay for paid services - this tool is 100%
      free and safer because your data never leaves your browser.
    </div>

    <div class="warning">
      <strong>üîí Privacy First:</strong> Your data never leaves your browser.
      Everything is processed locally on your device. No upload required -
      completely offline processing.
    </div>

    <div class="info-box">
      <h3>üì• First Time? Get Your Snapchat Data</h3>
      <p>
        Before using this tool, you need to download your data from Snapchat:
      </p>
      <ol>
        <li>
          <strong>Login</strong> to
          <a href="https://accounts.snapchat.com/" target="_blank">Snapchat's website</a>
        </li>
        <li>
          Click the <strong>menu</strong> in the top left corner
          <ul style="list-style: none; padding-left: 15px; margin: 5px 0">
            <li>Mobile: Tap "Accounts"</li>
            <li>Desktop: Click "Account Settings"</li>
          </ul>
        </li>
        <li>Click <strong>"My Data"</strong></li>
        <li>
          Select the data you want:
          <ul style="list-style: none; padding-left: 15px; margin: 5px 0">
            <li>‚úÖ <strong>Memories</strong> (required for this tool)</li>
            <li>‚úÖ <strong>Chat Media</strong> (optional - now separate)</li>
            <li>
              ‚úÖ <strong>Shared Stories</strong> (optional - now separate)
            </li>
          </ul>
        </li>
        <li>Click <strong>"Submit Request"</strong></li>
        <li>Wait for Snapchat to email you (24-48 hours)</li>
        <li>Download the ZIP and extract it</li>
        <li>
          Find <code>memories_history.html</code> in the
          <code>html/</code> folder
        </li>
      </ol>
      <p style="font-size: 14px; margin-top: 15px">
        <a href="https://www.reddit.com/r/techsupport/comments/18mkfvv/is_there_a_way_of_exporting_all_snapchat/"
          target="_blank">More info on Reddit</a>
      </p>
    </div>

    <div class="upload-section" id="uploadSection">
      <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#667eea" stroke-width="2"
        style="margin-bottom: 15px">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
      </svg>
      <h3 style="margin-bottom: 10px">Upload memories_history.html</h3>
      <p style="color: #666; margin-bottom: 20px">
        Drag and drop or click to browse
      </p>
      <input type="file" id="fileInput" accept=".html" />
      <label for="fileInput" class="btn">Choose HTML File</label>
      <p id="fileName" style="margin-top: 15px; color: #667eea; font-weight: 600"></p>

      <div style="
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
          ">
        <h4 style="margin-bottom: 10px; font-size: 16px">
          Resume/Retry (Optional)
        </h4>
        <p style="color: #666; margin-bottom: 15px; font-size: 14px">
          Upload metadata.json to resume or retry failed downloads (HTML file not required when resuming)
        </p>
        <input type="file" id="metadataInput" accept=".json" />
        <label for="metadataInput" class="btn" style="background: #28a745">Choose metadata.json</label>
        <p id="metadataFileName" style="margin-top: 10px; color: #28a745; font-weight: 600"></p>
      </div>

      <!-- Basic Options -->
      <div class="options-group">
        <div class="option-item">
          <label class="option-label">
            <input type="checkbox" id="mergeOverlaysCheckbox" style="width: 18px; height: 18px; cursor: pointer" checked />
            <span>Merge overlays</span>
          </label>
          <p class="option-description">
            Combine -main and -overlay files into a single file (recommended for most users)
          </p>
        </div>

        <div class="option-item" style="margin-top: 20px;">
          <label style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: 600;">Batch Size</label>
          <select id="batchSizeSelect" style="
                padding: 10px;
                border: 2px solid #667eea;
                border-radius: 6px;
                font-size: 14px;
                width: 100%;
                max-width: 250px;
                cursor: pointer;
              ">
            <option value="50" selected>50 files per batch (recommended)</option>
            <option value="100">100 files per batch</option>
            <option value="200">200 files per batch</option>
            <option value="0">All in one ZIP</option>
            <option value="10">10 files per batch</option>
            <option value="20">20 files per batch</option>
          </select>
          <p class="option-description" style="margin-left: 0;">
            Split downloads into multiple ZIPs for better browser performance
          </p>
        </div>
      </div>

      <!-- Filters (Collapsible) -->
      <details class="collapsible" style="margin-top: 25px;">
        <summary>Filter Options</summary>
        <div style="margin-top: 15px;">
          <div class="option-item">
            <label class="option-label">
              <input type="checkbox" id="overlaysOnlyCheckbox" style="width: 18px; height: 18px; cursor: pointer" />
              <span>Overlays only</span>
            </label>
            <p class="option-description">Only download memories with text/sticker overlays</p>
          </div>

          <div class="option-item">
            <label class="option-label">
              <input type="checkbox" id="videosOnlyCheckbox" style="width: 18px; height: 18px; cursor: pointer" />
              <span>Videos only</span>
            </label>
            <p class="option-description">Skip all pictures</p>
          </div>

          <div class="option-item">
            <label class="option-label">
              <input type="checkbox" id="picturesOnlyCheckbox" style="width: 18px; height: 18px; cursor: pointer" />
              <span>Pictures only</span>
            </label>
            <p class="option-description">Skip all videos</p>
          </div>
        </div>
      </details>

      <!-- Advanced Options (Collapsible) -->
      <details class="collapsible" style="margin-top: 20px;">
        <summary>Advanced Options</summary>
        <div style="margin-top: 15px;">
          <div class="option-item">
            <label class="option-label">
              <input type="checkbox" id="deferVideoOverlaysCheckbox" style="width: 18px; height: 18px; cursor: pointer" checked />
              <span>Process video overlays at end</span>
            </label>
            <p class="option-description">
              Keep all files in the same batch - process video overlays after downloading everything (recommended)
            </p>
          </div>

          <div class="option-item">
            <label class="option-label">
              <input type="checkbox" id="timestampFilenamesCheckbox" style="width: 18px; height: 18px; cursor: pointer" />
              <span>Timestamp-based filenames</span>
            </label>
            <p class="option-description">Name files as YYYY.MM.DD-HH:MM:SS.ext instead of sequential numbers</p>
          </div>

          <div class="option-item" style="margin-top: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: 600;">Video Memory Management</label>
            <select id="ffmpegResetIntervalSelect" style="
                  padding: 10px;
                  border: 2px solid #667eea;
                  border-radius: 6px;
                  font-size: 14px;
                  width: 100%;
                  max-width: 300px;
                  cursor: pointer;
                ">
              <option value="5" selected>Reset every 5 videos (recommended)</option>
              <option value="3">Reset every 3 videos (safest)</option>
              <option value="10">Reset every 10 videos (faster)</option>
              <option value="999">Never reset (risky)</option>
            </select>
            <p class="option-description" style="margin-left: 0;">
              How often to restart the video processor to prevent memory buildup
            </p>
          </div>

          <div class="option-item" style="margin-top: 20px;">
            <label style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: 600;">Download Rate Limiting</label>
            <select id="rateLimitDelaySelect" style="
                  padding: 10px;
                  border: 2px solid #667eea;
                  border-radius: 6px;
                  font-size: 14px;
                  width: 100%;
                  max-width: 300px;
                  cursor: pointer;
                ">
              <option value="0">No delay (fastest, may hit rate limits)</option>
              <option value="100">100ms delay (recommended)</option>
              <option value="250">250ms delay (safer)</option>
              <option value="500" selected>500ms delay (safest for large batches)</option>
              <option value="1000">1 second delay (very safe)</option>
            </select>
            <p class="option-description" style="margin-left: 0;">
              Delay between downloads to avoid AWS/Snapchat rate limits. Use 500ms+ if seeing frequent 500 errors.
            </p>
          </div>
        </div>
      </details>

      <div style="margin-top: 30px; text-align: center">
        <button id="startButton" style="
              display: none;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              border: none;
              padding: 15px 40px;
              font-size: 18px;
              font-weight: bold;
              border-radius: 8px;
              cursor: pointer;
              box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
              transition: transform 0.2s, box-shadow 0.2s;
            "
          onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.6)'"
          onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)'"
          onclick="handleStartDownload()">
          üöÄ Start Download
        </button>
        <button id="stopButton" style="
              display: none;
              background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
              color: white;
              border: none;
              padding: 15px 40px;
              font-size: 18px;
              font-weight: bold;
              border-radius: 8px;
              cursor: pointer;
              box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
              transition: transform 0.2s, box-shadow 0.2s;
            "
          onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(220, 53, 69, 0.6)'"
          onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 15px rgba(220, 53, 69, 0.4)'"
          onclick="handleStopDownload()">
          üõë Stop & Save Progress
        </button>
      </div>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="status" id="status">Preparing download...</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill">0%</div>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <div style="color: #666; font-size: 14px; font-weight: 600;">Activity Logs</div>
        <button id="copyLogsBtn" class="btn" style="padding: 6px 15px; font-size: 13px;" onclick="copyLogsToClipboard()">
          üìã Copy Logs
        </button>
      </div>

      <div class="log-tabs">
        <button class="log-tab active" onclick="switchLogTab('main')">Main Activity</button>
        <button class="log-tab" onclick="switchLogTab('ffmpeg')">FFmpeg Details</button>
      </div>

      <div id="log-main" class="log-content active">
        <div class="log" id="log"></div>
      </div>

      <div id="log-ffmpeg" class="log-content">
        <div class="log" id="logFFmpeg"></div>
      </div>
    </div>

    <div class="features">
      <h2>Why Use This Free Tool?</h2>
      <ul>
        <li>
          <strong>100% FREE</strong> - Don't pay for paid services that charge
          money
        </li>
        <li>
          <strong>Save Before Snapchat Charges</strong> - Download now before
          storage fees kick in
        </li>
        <li>
          <strong>Completely Private</strong> - No upload required, runs in
          your browser offline
        </li>
        <li>
          <strong>Preserves Everything</strong> - GPS coordinates, dates, and
          all metadata intact
        </li>
        <li>
          <strong>Handles Overlays</strong> - Extracts both main and overlay
          files from edited snaps
        </li>
        <li>
          <strong>Optional Overlay Merging</strong> - Combine overlays with
          main images for cleaner organization
        </li>
        <li>
          <strong>Resume Support</strong> - Pick up where you left off if
          interrupted
        </li>
        <li>
          <strong>Safe & Secure</strong> - Your memories never leave your
          computer
        </li>
        <li>
          <strong>One-Click Download</strong> - Get everything in a convenient
          ZIP file
        </li>
      </ul>
    </div>

    <div class="features">
      <h2>Frequently Asked Questions</h2>
      <div style="text-align: left; padding-left: 20px">
        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">Is this really free?</h3>
        <p style="margin-bottom: 15px;">
          Yes! 100% free, forever. No hidden costs or premium features.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          Is it safe? Do you upload my photos?
        </h3>
        <p style="margin-bottom: 15px;">
          Completely safe. Everything runs in your browser - no uploads, no cloud processing. Your data never leaves your device.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          Does it preserve GPS location and dates?
        </h3>
        <p style="margin-bottom: 15px;">
          Yes! All metadata is preserved including GPS coordinates, dates, and media types.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          What if the download fails or gets interrupted?
        </h3>
        <p style="margin-bottom: 15px;">
          Upload your metadata.json file (included in each ZIP) to resume. You don't need the HTML file again - all progress is saved.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          Can I download Chat Media and Shared Stories too?
        </h3>
        <p style="margin-bottom: 15px;">
          Yes! Select "Chat Media" and "Shared Stories" when requesting your data from Snapchat.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          Videos won't play on Windows?
        </h3>
        <p>
          Snapchat videos use HEVC codec (H.265), which Windows doesn't include by default.
        </p>
        <p style="margin-top: 10px;"><strong>Quick Fix:</strong></p>
        <ol style="margin-left: 20px; margin-top: 5px;">
          <li>Install <a href="https://apps.microsoft.com/detail/9n4wgh0z6vhq" target="_blank" style="color: #667eea; font-weight: 600;">HEVC codec from Microsoft Store</a> (FREE)</li>
          <li><strong>Or</strong> use <a href="https://www.videolan.org/vlc/" target="_blank" style="color: #667eea;">VLC Media Player</a> (plays HEVC without codec)</li>
        </ol>
        <p style="margin-top: 10px;">
          <strong>Note:</strong> Not a bug - videos are downloading correctly. This is a Windows limitation.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          Videos are coming out black with audio?
        </h3>
        <p style="margin-bottom: 10px;">
          <strong>Recent Fix:</strong> The tool now automatically converts WebP/JPEG/etc overlays to PNG before processing, which fixes most black screen issues.
        </p>
        <p><strong>If you still have issues:</strong></p>
        <ol style="margin-left: 20px; margin-top: 5px; margin-bottom: 10px;">
          <li>Hard refresh the page (Ctrl+F5 or Cmd+Shift+R)</li>
          <li>Check the "FFmpeg Details" tab for errors</li>
          <li>Try a different browser (Chrome/Edge recommended)</li>
        </ol>
        <p><strong>Still failing? Use the Python script:</strong></p>
        <ol style="margin-left: 20px; margin-top: 5px; margin-bottom: 10px;">
          <li>Download: <code>git clone https://github.com/andrefecto/Snapchat-Memories-Downloader.git</code></li>
          <li>Install FFmpeg (<a href="https://ffmpeg.org/download.html" target="_blank" style="color: #667eea;">ffmpeg.org</a>)</li>
          <li>Run: <code>python download_memories.py</code></li>
        </ol>
        <p style="margin-bottom: 15px;">
          The Python script uses native FFmpeg and is 100% reliable.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          How does individual video processing work?
        </h3>
        <p style="margin-bottom: 10px;">
          To ensure <strong>zero memory accumulation</strong>, the tool uses a smart download strategy:
        </p>
        <ul style="margin-left: 20px; margin-top: 5px; margin-bottom: 10px;">
          <li><strong>Images:</strong> Merged overlays accumulate in batch ZIP</li>
          <li><strong>Videos with overlays (immediate merge):</strong> Each gets its own ZIP to prevent memory buildup</li>
          <li><strong>Videos with overlays (deferred):</strong> Stay in batch, processed later</li>
          <li><strong>Videos without overlays:</strong> Stay in batch ZIP</li>
        </ul>
        <p style="margin-bottom: 15px;">
          Use <strong>"Process video overlays at end"</strong> to get fewer ZIP files overall.
        </p>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          How do I report issues or bugs?
        </h3>
        <ol style="margin-left: 20px; margin-top: 5px; margin-bottom: 15px;">
          <li>Click <strong>"üìã Copy Logs"</strong> button</li>
          <li>Go to <a href="https://github.com/andrefecto/Snapchat-Memories-Downloader/issues" target="_blank" style="color: #667eea; font-weight: 600;">GitHub Issues</a></li>
          <li>Create new issue and paste logs</li>
          <li>Include browser type and device specs</li>
        </ol>

        <h3 style="margin-top: 30px; margin-bottom: 10px; color: #667eea; font-size: 1.1em;">
          Videos won't play when I open the ZIP file?
        </h3>
        <p style="margin-bottom: 10px;">
          <strong>Important:</strong> You must <strong>extract the files from the ZIP</strong> before trying to view them!
        </p>
        <p style="margin-bottom: 5px;">Most video players cannot play videos directly from inside a ZIP file.</p>
        <ol style="margin-left: 20px; margin-top: 5px; margin-bottom: 10px;">
          <li>Right-click ZIP ‚Üí "Extract All" (Windows) or double-click (Mac)</li>
          <li>Open videos from the extracted folder</li>
          <li>For multiple ZIPs: Use <a href="https://www.7-zip.org/" target="_blank" style="color: #667eea; font-weight: 600;">7-Zip</a> (free)</li>
        </ol>
        <p style="margin-bottom: 15px;">
          <strong>7-Zip Tip:</strong> Select all ZIPs ‚Üí Right-click ‚Üí 7-Zip ‚Üí "Extract Here" to batch extract.
        </p>
      </div>
    </div>

    <div class="footer-links">
      <div style="margin-bottom: 15px">
        <a class="github-badge" href="https://github.com/andrefecto" target="_blank">
          <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
            <path
              d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
          </svg>
          andrefecto
        </a>
      </div>
      <div style="margin-bottom: 15px">
        <a class="coffee-btn" href="https://buymeacoffee.com/andrefecto" target="_blank">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M20.216 6.415l-.132-.666c-.119-.598-.388-1.163-1.001-1.379-.197-.069-.42-.098-.57-.241-.152-.143-.196-.366-.231-.572-.065-.378-.125-.756-.192-1.133-.057-.325-.102-.69-.25-.987-.195-.4-.597-.634-.996-.788a5.723 5.723 0 00-.626-.194c-1-.263-2.05-.36-3.077-.416a25.834 25.834 0 00-3.7.062c-.915.083-1.88.184-2.75.5-.318.116-.646.256-.888.501-.297.302-.393.77-.177 1.146.154.267.415.456.692.58.36.162.737.284 1.123.366 1.075.238 2.189.331 3.287.37 1.218.05 2.437.01 3.65-.118.299-.033.598-.073.896-.119.352-.054.578-.513.474-.834-.124-.383-.457-.531-.834-.473-.466.074-.96.108-1.382.146-1.177.08-2.358.082-3.536.006a22.228 22.228 0 01-1.157-.107c-.086-.01-.18-.025-.258-.036-.243-.036-.484-.08-.724-.13-.111-.027-.111-.185 0-.212h.005c.277-.06.557-.108.838-.147h.002c.131-.009.263-.032.394-.048a25.076 25.076 0 013.426-.12c.674.019 1.347.067 2.017.144l.228.031c.267.04.533.088.798.145.392.085.895.113 1.07.542.055.137.08.288.111.431l.319 1.484a.237.237 0 01-.199.284h-.003c-.037.006-.075.01-.112.015a36.704 36.704 0 01-4.743.295 37.059 37.059 0 01-4.699-.304c-.14-.017-.293-.042-.417-.06-.326-.048-.649-.108-.973-.161-.393-.065-.768-.032-1.123.161-.29.16-.527.404-.675.701-.154.316-.199.66-.267 1-.069.34-.176.707-.135 1.056.087.753.613 1.365 1.37 1.502a39.69 39.69 0 0011.343.376.483.483 0 01.535.53l-.071.697-1.018 9.907c-.041.41-.047.832-.125 1.237-.122.637-.553 1.028-1.182 1.171-.577.131-1.165.2-1.756.205-.656.004-1.31-.025-1.966-.022-.699.004-1.556-.06-2.095-.58-.475-.458-.54-1.174-.605-1.793l-.731-7.013-.322-3.094c-.037-.351-.286-.695-.678-.678-.336.015-.718.3-.678.679l.228 2.185.949 9.112c.147 1.344 1.174 2.068 2.446 2.272.742.12 1.503.144 2.257.156.966.016 1.942.053 2.892-.122 1.408-.258 2.465-1.198 2.616-2.657.34-3.332.683-6.663 1.024-9.995l.215-2.087a.484.484 0 01.39-.426c.402-.078.787-.212 1.074-.518.455-.488.546-1.124.385-1.766zm-1.478.772c-.145.137-.363.201-.578.233-2.416.359-4.866.54-7.308.46-1.748-.06-3.477-.254-5.207-.498-.17-.024-.353-.055-.47-.18-.22-.236-.111-.71-.054-.995.052-.26.152-.609.463-.646.484-.057 1.046.148 1.526.22.577.088 1.156.159 1.737.212 2.48.226 5.002.19 7.472-.14.45-.06.899-.13 1.345-.21.399-.072.84-.206 1.08.206.166.281.188.657.162.974a.544.544 0 01-.169.364zm-6.159 3.9c-.862.37-1.84.788-3.109.788a5.884 5.884 0 01-1.569-.217l.877 9.004c.065.78.717 1.38 1.5 1.38 0 0 1.243.065 1.658.065.447 0 1.786-.065 1.786-.065.783 0 1.434-.6 1.499-1.38l.94-9.95a3.996 3.996 0 00-1.322-.238c-.826 0-1.491.284-2.26.613z" />
          </svg>
          Buy Me a Coffee
        </a>
      </div>
      <div style="color: #666; font-size: 14px">
        <a href="https://github.com/andrefecto/Snapchat-Memories-Downloader" target="_blank">
          View Source on GitHub
        </a>
        |
        <a href="https://github.com/andrefecto/Snapchat-Memories-Downloader#python-script" target="_blank">
          Python Script Version
        </a>
      </div>
      <div style="color: #999; font-size: 12px; margin-top: 10px" id="version-display">
        <!-- Version will be inserted here by JavaScript -->
      </div>
    </div>
  </div>

  <script>
    // Version number - automatically updated by GitHub Actions on tag push
    const APP_VERSION = 'v1.2.7';
    // Global resource load error listener for debugging 404s
    window.addEventListener('error', function (e) {
      try {
        const src = e?.target?.src || e?.target?.href || null;
        if (src) console.error('Resource load failed:', src, e);
      } catch (err) {
        console.error('Error in resource load listener', err);
      }
    }, true);

    const fileInput = document.getElementById("fileInput");
    const metadataInput = document.getElementById("metadataInput");
    const uploadSection = document.getElementById("uploadSection");
    const fileName = document.getElementById("fileName");
    const metadataFileName = document.getElementById("metadataFileName");
    const startButton = document.getElementById("startButton");
    const stopButton = document.getElementById("stopButton");
    const progressContainer = document.getElementById("progressContainer");
    const progressFill = document.getElementById("progressFill");
    const status = document.getElementById("status");
    const log = document.getElementById("log");

    let memories = [];
    let existingMetadata = null;
    let existingSettings = null; // Store settings from metadata.json
    let currentIndex = 0;
    let zip = null;
    let deferredVideoOverlays = []; // Track videos with overlays for deferred processing
    let shouldStop = false; // Flag to stop download gracefully
    let currentMetadataList = []; // Track current download progress for stop feature

    // FFmpeg.wasm for video overlay merging
    let ffmpegLoaded = false;
    let ffmpegInstance = null;
    let videosProcessedSinceReset = 0;
    let totalVideosProcessed = 0;

    // Display version info
    console.log(`%cSnapchat Memories Downloader ${APP_VERSION}`, 'font-weight: bold; font-size: 14px; color: #667eea;');
    console.log(`Report issues: https://github.com/andrefecto/Snapchat-Memories-Downloader/issues`);
    const versionDisplay = document.getElementById('version-display');
    if (versionDisplay) {
      versionDisplay.textContent = `Web Version ${APP_VERSION}`;
    }

    /**
     * Terminate FFmpeg.wasm instance and release memory.
     *
     * CRITICAL: FFmpeg.wasm has memory leak issues in browser environments.
     * Processing multiple videos without resetting causes:
     * - Gradual memory accumulation (WASM heap grows but doesn't shrink)
     * - Browser slowdown and eventual crashes
     * - Black screen output from FFmpeg after N videos
     *
     * Solution: Periodically terminate and recreate FFmpeg instance.
     * This forces browser garbage collection of WASM memory.
     *
     * Called:
     * - After processing N videos (configurable: 5, 10, 20, or unlimited)
     * - After errors to ensure clean state for next attempt
     * - On force reload
     */
    async function terminateFFmpeg() {
      if (ffmpegInstance) {
        try {
          // Remove all event listeners to prevent memory leaks
          ffmpegInstance.off('log');
          ffmpegInstance.off('progress');
          // Note: FFmpeg.wasm doesn't have a built-in terminate/destroy method
          // Setting to null allows JavaScript garbage collection
          ffmpegInstance = null;
          ffmpegLoaded = false;
          videosProcessedSinceReset = 0;
          addLog('  FFmpeg instance terminated, memory released', 'info');
          // Give browser time to garbage collect WASM memory
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.warn('Error terminating FFmpeg:', error);
        }
      }
    }

    /**
     * Initialize FFmpeg.wasm instance with memory leak mitigation.
     *
     * FFmpeg.wasm Memory Management:
     * - WebAssembly modules don't automatically garbage collect memory
     * - Processing videos accumulates memory in WASM heap
     * - Auto-reset after N videos prevents memory exhaustion
     *
     * Reset Intervals (user configurable):
     * - 5 videos: Most aggressive, safest for low-memory devices
     * - 10 videos: Balanced (default)
     * - 20 videos: Less frequent resets, faster for high-memory systems
     * - Unlimited: No auto-reset (risky, only for small batches)
     *
     * Browser Compatibility:
     * - Chrome/Edge: Best support, memory monitoring available
     * - Firefox: Known WASM issues, may produce black screens
     * - Safari: Generally works but slower
     *
     * @param {boolean} forceReload - Force recreation even if already loaded
     * @returns {FFmpeg} FFmpeg.wasm instance
     */
    async function initFFmpeg(forceReload = false) {
      // Check if we need to reset due to memory concerns
      const resetInterval = parseInt(document.getElementById('ffmpegResetIntervalSelect')?.value || '5', 10);

      if (forceReload || (videosProcessedSinceReset >= resetInterval && resetInterval < 999)) {
        if (ffmpegInstance) {
          addLog(`  Resetting FFmpeg after ${videosProcessedSinceReset} videos (prevents memory buildup)`, 'info');
          await terminateFFmpeg();
        }
      }

      if (ffmpegLoaded && ffmpegInstance) {
        return ffmpegInstance;
      }

      const { FFmpeg } = FFmpegWASM;
      ffmpegInstance = new FFmpeg();

      // Detect browser
      const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
      const isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

      if (isFirefox) {
        addLog('  ‚ö†Ô∏è Firefox detected: Video merging may be unstable due to WASM limitations', 'warning');
        addLog('  Recommendation: Use Chrome or Edge for best results', 'warning');
        addLog('Firefox browser detected - known WASM/FFmpeg compatibility issues', 'warning', 'ffmpeg');
      }

      addLog('  Loading FFmpeg.wasm (this may take a few seconds)...', 'info');
      addLog('  üí° Check the "FFmpeg Details" tab for detailed conversion logs', 'info');
      addLog('Loading FFmpeg.wasm...', 'info', 'ffmpeg');

      await ffmpegInstance.load({
        coreURL: new URL('./ffmpeg/ffmpeg-core.js', window.location).href,
        wasmURL: new URL('./ffmpeg/ffmpeg-core.wasm', window.location).href,
        worker: false
      });

      // Log FFmpeg backend messages to FFmpeg tab
      ffmpegInstance.on('log', (m) => {
        try {
          const message = m && m.message ? m.message : JSON.stringify(m);
          addLog(message, 'ffmpeg', 'ffmpeg');
        } catch(e) {
          // Ignore logging errors
        }
      });

      ffmpegLoaded = true;
      videosProcessedSinceReset = 0;
      addLog('  FFmpeg loaded successfully', 'success');
      addLog('FFmpeg loaded and ready', 'success', 'ffmpeg');
      return ffmpegInstance;
    }

    /**
     * Check memory usage and warn if getting low (Chrome only)
     */
    function checkMemoryUsage() {
      try {
        if (performance.memory) {
          const usedMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
          const limitMB = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
          const percentUsed = Math.round((usedMB / limitMB) * 100);

          if (percentUsed > 80) {
            addLog(`  ‚ö†Ô∏è Memory usage high: ${usedMB}MB / ${limitMB}MB (${percentUsed}%)`, 'info');
            addLog(`  Recommendation: Close other tabs or reduce reset interval`, 'info');
          } else if (percentUsed > 60) {
            addLog(`  Memory usage: ${usedMB}MB / ${limitMB}MB (${percentUsed}%)`, 'info');
          }
          return { usedMB, limitMB, percentUsed };
        }
      } catch (e) {
        // performance.memory not available (Firefox, Safari)
      }
      return null;
    }

    /**
    * Parse Snapchat date string to JavaScript Date object
    * Format: "2025-11-30 00:31:09 UTC"
    */
    function parseSnapchatDate(dateStr) {
      try {
        // Remove " UTC" suffix and parse
        const dateStrClean = dateStr.replace(" UTC", "");
        return new Date(dateStrClean + "Z"); // Add Z to indicate UTC
      } catch (error) {
        console.error("mergeVideoOverlay error:", error);
        console.warn("Could not parse date:", dateStr, error);
        return new Date(); // Fallback to current date
      }
    }

    /**
     * Generate filename based on timestamp setting
     * @param {string} dateStr - Snapchat date string (e.g., "2025-11-30 00:31:09 UTC")
     * @param {string} extension - File extension (e.g., ".mp4")
     * @param {boolean} useTimestamp - If true, use timestamp format; if false, use sequential number
     * @param {string} fallbackNum - Sequential number to use if useTimestamp is false (e.g., "001")
     * @returns {string} Filename (e.g., "2025.11.30-00:31:09.mp4" or "001.mp4")
     */
    function generateFilename(dateStr, extension, useTimestamp, fallbackNum) {
      if (useTimestamp) {
        try {
          // Parse date string: "2025-11-30 00:31:09 UTC" -> "2025.11.30-00.31.09"
          // Replace colons with dots to ensure Windows compatibility
          const dateStrClean = dateStr.replace(" UTC", "").trim();
          const parts = dateStrClean.split(" ");
          if (parts.length === 2) {
            const datePart = parts[0].replace(/-/g, "."); // "2025.11.30"
            const timePart = parts[1].replace(/:/g, "."); // "00.31.09" (Windows-safe)
            return `${datePart}-${timePart}${extension}`;
          } else {
            // Fallback to sequential if date format is unexpected
            console.warn(`Unexpected date format '${dateStr}', using sequential number`);
            return `${fallbackNum}${extension}`;
          }
        } catch (e) {
          console.warn(`Could not parse date for filename '${dateStr}':`, e, ', using sequential number');
          return `${fallbackNum}${extension}`;
        }
      } else {
        return `${fallbackNum}${extension}`;
      }
    }

    /**
     * Convert decimal degrees to degrees, minutes, seconds for EXIF
     */
    function decimalToDMS(decimal) {
      const absolute = Math.abs(decimal);
      const degrees = Math.floor(absolute);
      const minutesDecimal = (absolute - degrees) * 60;
      const minutes = Math.floor(minutesDecimal);
      const seconds = (minutesDecimal - minutes) * 60;

      return [
        [degrees, 1],
        [minutes, 1],
        [Math.round(seconds * 100), 100],
      ];
    }

    // Detect common file extension from file bytes (Uint8Array)
    function detectFileExtension(uint8array) {
      if (!uint8array || uint8array.length < 12) return null;
      // PNG
      if (uint8array[0] === 0x89 && uint8array[1] === 0x50 && uint8array[2] === 0x4e && uint8array[3] === 0x47) return '.png';
      // JPEG
      if (uint8array[0] === 0xff && uint8array[1] === 0xd8 && uint8array[2] === 0xff) return '.jpg';
      // WebP (RIFF....WEBP)
      if (
        uint8array[0] === 0x52 &&
        uint8array[1] === 0x49 &&
        uint8array[2] === 0x46 &&
        uint8array[3] === 0x46 &&
        uint8array[8] === 0x57 &&
        uint8array[9] === 0x45 &&
        uint8array[10] === 0x42 &&
        uint8array[11] === 0x50
      )
        return '.webp';
      // GIF
      if (uint8array[0] === 0x47 && uint8array[1] === 0x49 && uint8array[2] === 0x46) return '.gif';
      // MP4 (ftyp at bytes 4-7)
      if (
        uint8array.length >= 12 &&
        uint8array[4] === 0x66 &&
        uint8array[5] === 0x74 &&
        uint8array[6] === 0x79 &&
        uint8array[7] === 0x70
      )
        return '.mp4';
      return null;
    }

    /**
     * Add EXIF metadata (GPS and date) to image
     * Preserves original image format (JPEG, PNG, WebP, etc.)
     * @param {ArrayBuffer} imageData - Image data
     * @param {string} dateStr - Date string from Snapchat
     * @param {string} latitude - Latitude as string
     * @param {string} longitude - Longitude as string
     * @returns {Promise<ArrayBuffer>} - Image with EXIF metadata
     */
    async function addExifMetadata(imageData, dateStr, latitude, longitude) {
      if (typeof piexif === "undefined") {
        console.warn("piexif library not loaded, skipping EXIF metadata");
        return imageData;
      }

      try {
        // Convert ArrayBuffer to base64 for piexif
        const uint8Array = new Uint8Array(imageData);

        // Detect image format from magic bytes
        let mimeType = "image/jpeg"; // default
        if (uint8Array[0] === 0x89 && uint8Array[1] === 0x50 && uint8Array[2] === 0x4E && uint8Array[3] === 0x47) {
          mimeType = "image/png";
        } else if (uint8Array[0] === 0x52 && uint8Array[1] === 0x49 && uint8Array[2] === 0x46 && uint8Array[3] === 0x46) {
          mimeType = "image/webp";
        } else if (uint8Array[0] === 0xFF && uint8Array[1] === 0xD8) {
          mimeType = "image/jpeg";
        }

        // piexif.insert() only works with JPEG
        // For PNG/WebP, we can't add EXIF via piexif.js, so just return original
        if (mimeType !== "image/jpeg") {
          console.log(`Skipping EXIF for ${mimeType} (piexif.js only supports JPEG)`);
          return imageData;
        }

        let binary = "";
        for (let i = 0; i < uint8Array.byteLength; i++) {
          binary += String.fromCharCode(uint8Array[i]);
        }
        const base64 = btoa(binary);
        const dataUrl = "data:" + mimeType + ";base64," + base64;

        // Create EXIF object
        const exifObj = { "0th": {}, Exif: {}, GPS: {} };

        // Add date/time
        if (dateStr && dateStr !== "Unknown") {
          try {
            const date = parseSnapchatDate(dateStr);
            const exifDate =
              date.getFullYear() +
              ":" +
              String(date.getMonth() + 1).padStart(2, "0") +
              ":" +
              String(date.getDate()).padStart(2, "0") +
              " " +
              String(date.getHours()).padStart(2, "0") +
              ":" +
              String(date.getMinutes()).padStart(2, "0") +
              ":" +
              String(date.getSeconds()).padStart(2, "0");

            exifObj["Exif"][piexif.ExifIFD.DateTimeOriginal] = exifDate;
            exifObj["Exif"][piexif.ExifIFD.DateTimeDigitized] = exifDate;
            exifObj["0th"][piexif.ImageIFD.DateTime] = exifDate;
          } catch (e) {
            console.warn("Could not parse date for EXIF:", e);
          }
        }

        // Add GPS coordinates
        if (
          latitude &&
          longitude &&
          latitude !== "Unknown" &&
          longitude !== "Unknown"
        ) {
          const lat = parseFloat(latitude);
          const lon = parseFloat(longitude);

          if (!isNaN(lat) && !isNaN(lon)) {
            // Latitude
            exifObj["GPS"][piexif.GPSIFD.GPSLatitude] = decimalToDMS(lat);
            exifObj["GPS"][piexif.GPSIFD.GPSLatitudeRef] =
              lat >= 0 ? "N" : "S";

            // Longitude
            exifObj["GPS"][piexif.GPSIFD.GPSLongitude] = decimalToDMS(lon);
            exifObj["GPS"][piexif.GPSIFD.GPSLongitudeRef] =
              lon >= 0 ? "E" : "W";
          }
        }

        // Insert EXIF into image
        const exifBytes = piexif.dump(exifObj);
        const newDataUrl = piexif.insert(exifBytes, dataUrl);

        // Convert back to ArrayBuffer
        const newBase64 = newDataUrl.split(",")[1];
        const newBinary = atob(newBase64);
        const newUint8Array = new Uint8Array(newBinary.length);
        for (let i = 0; i < newBinary.length; i++) {
          newUint8Array[i] = newBinary.charCodeAt(i);
        }

        return newUint8Array.buffer;
      } catch (error) {
        console.warn("Could not add EXIF metadata:", error);
        return imageData;
      }
    }

    /**
     * Add GPS and timestamp metadata to video using FFmpeg.wasm
     *
     * Adds creation_time and GPS location metadata to MP4 files for compatibility
     * with Apple Photos, Google Photos, and other media apps.
     *
     * CRITICAL for Apple Photos:
     * - Sets com.apple.quicktime.creationdate (Apple Photos uses this instead of creation_time)
     * - Without this, videos import at wrong local time even when GPS is present
     * - NOTE: Web version only supports UTC timestamps (Python version has timezone conversion)
     *
     * Metadata fields set:
     * - creation_time: ISO 8601 timestamp in UTC
     * - com.apple.quicktime.creationdate: QuickTime-specific date field (UTC)
     * - com.apple.quicktime.make: Device identifier ("Snapchat")
     * - location: ISO 6709 format (e.g., "+34.0522-118.2437/")
     * - location-eng: Human-readable format (e.g., "34.052235, -118.243683")
     * - com.apple.quicktime.location.ISO6709: Apple-specific GPS format
     *
     * @param {ArrayBuffer} videoData - Video data (MP4)
     * @param {string} dateStr - Date string from Snapchat (e.g., "2025-11-30 00:31:09 UTC")
     * @param {string} latitude - Latitude as string (e.g., "34.052235")
     * @param {string} longitude - Longitude as string (e.g., "-118.243683")
     * @returns {Promise<ArrayBuffer>} - Video with metadata added
     */
    async function addVideoMetadata(videoData, dateStr, latitude, longitude) {
      // Skip if no GPS coordinates available
      if (!latitude || !longitude || latitude === "Unknown" || longitude === "Unknown") {
        console.log("Skipping video metadata (no GPS coordinates)");
        return videoData;
      }

      try {
        // CRITICAL: Check if ArrayBuffer is detached before processing
        if (videoData.byteLength === 0 || videoData.detached) {
          console.warn("ArrayBuffer is detached, skipping video metadata");
          addLog(`  Warning: Video data corrupted (detached buffer), skipping metadata`, "warning");
          return videoData;
        }

        // CRITICAL: Create a COPY of the ArrayBuffer to prevent detachment
        // FFmpeg.wasm operations can detach/transfer buffers, causing issues downstream
        const videoDataCopy = videoData.slice(0);

        const ffmpeg = await initFFmpeg();
        if (!ffmpeg) {
          console.warn("FFmpeg.wasm not available, skipping video metadata");
          return videoData;
        }

        // Parse coordinates
        const lat = parseFloat(latitude);
        const lon = parseFloat(longitude);

        if (isNaN(lat) || isNaN(lon)) {
          console.warn("Invalid GPS coordinates, skipping video metadata");
          return videoData;
        }

        // Parse date for creation_time metadata
        let creationTime;
        try {
          const dateClean = dateStr.replace(" UTC", "");
          const dt = new Date(dateClean + "Z"); // UTC
          creationTime = dt.toISOString(); // ISO 8601 format with 'Z' suffix
        } catch (e) {
          console.warn("Could not parse date for video metadata:", dateStr);
          return videoData; // Return original if date parsing fails
        }

        addLog(`  Adding GPS metadata to video (${lat.toFixed(4)}, ${lon.toFixed(4)})...`, "info");

        // Write input video to FFmpeg virtual filesystem (use the copy!)
        await ffmpeg.writeFile("input.mp4", new Uint8Array(videoDataCopy));

        // Build FFmpeg command - copy video streams, only update metadata (fast)
        const args = [
          "-i", "input.mp4",
          // Generic metadata (cross-platform)
          "-metadata", `creation_time=${creationTime}`,
          "-metadata", `location=${lat >= 0 ? '+' : ''}${lat.toFixed(6)}${lon >= 0 ? '+' : ''}${lon.toFixed(6)}/`,
          "-metadata", `location-eng=${lat}, ${lon}`,
          // QuickTime-specific metadata (CRITICAL for Apple Photos)
          "-metadata", `com.apple.quicktime.creationdate=${creationTime}`,
          "-metadata", `com.apple.quicktime.make=Snapchat`,
          "-metadata", `com.apple.quicktime.location.ISO6709=${lat >= 0 ? '+' : ''}${lat.toFixed(4).padStart(8, '0')}${lon >= 0 ? '+' : ''}${lon.toFixed(4).padStart(9, '0')}/`,
          // Stream copy - no re-encoding
          "-codec", "copy",  // Copy streams without re-encoding (fast!)
          "-y",              // Overwrite output
          "output.mp4"
        ];

        addLog(`  Running FFmpeg metadata update (stream copy, no re-encode)...`, "info");
        await ffmpeg.exec(args);

        // Read output file
        const outputData = await ffmpeg.readFile("output.mp4");

        // Validate output size
        if (outputData.byteLength < 1000) {
          addLog(`WARNING: Output video is suspiciously small (${outputData.byteLength} bytes)`, "warning");
          console.warn("addVideoMetadata output too small:", outputData.byteLength);
          return videoData; // Return original on failure
        }

        // Clean up virtual filesystem
        await ffmpeg.deleteFile("input.mp4");
        await ffmpeg.deleteFile("output.mp4");

        // CRITICAL BUG FIX: Must use .slice().buffer, NOT .buffer directly!
        // FFmpeg.readFile() returns a Uint8Array that may be a VIEW into a larger ArrayBuffer.
        // Using .buffer directly returns the ENTIRE underlying ArrayBuffer (with garbage data).
        // This creates corrupted video files with extra bytes at the end.
        // Solution: .slice() creates NEW Uint8Array with ONLY the valid data, then extract .buffer
        addLog(`  Video metadata added successfully`, "success");

        // Increment counter for FFmpeg auto-reset (critical for memory management!)
        videosProcessedSinceReset++;
        totalVideosProcessed++;

        return outputData.slice().buffer;

      } catch (error) {
        console.warn("Could not add video metadata:", error);
        const errorMsg = error.message || error.toString() || 'unknown error';

        // Check for memory-related errors - force FFmpeg reset
        if (errorMsg.includes('memory access out of bounds') ||
            errorMsg.includes('RuntimeError') ||
            errorMsg.includes('detached')) {
          addLog(`  CRITICAL: FFmpeg memory error detected, forcing reset...`, "error");
          console.error("FFmpeg memory error, forcing reset:", error);
          await terminateFFmpeg();
          videosProcessedSinceReset = 0;
        }

        addLog(`  Warning: Failed to add video metadata: ${errorMsg}`, "warning");
        return videoData; // Return original video on error
      }
    }

    /**
     * Merge overlay image on top of main image using Canvas API
     * @param {ArrayBuffer} mainData - Main image data
     * @param {ArrayBuffer} overlayData - Overlay image data
     * @returns {Promise<ArrayBuffer>} - Merged image as JPEG
     */
    async function mergeImageOverlay(mainData, overlayData) {
      return new Promise((resolve, reject) => {
        // Detect image formats for better error messages
        const mainFormat = detectFileExtension(new Uint8Array(mainData)) || 'unknown';
        const overlayFormat = detectFileExtension(new Uint8Array(overlayData)) || 'unknown';

        // Create blobs with proper MIME types if possible
        const mainMime = getImageMimeType(mainFormat);
        const overlayMime = getImageMimeType(overlayFormat);

        const mainBlob = new Blob([mainData], mainMime ? { type: mainMime } : undefined);
        const overlayBlob = new Blob([overlayData], overlayMime ? { type: overlayMime } : undefined);

        // Create image URLs
        const mainUrl = URL.createObjectURL(mainBlob);
        const overlayUrl = URL.createObjectURL(overlayBlob);

        // Load main image
        const mainImg = new Image();
        const overlayImg = new Image();

        let mainLoaded = false;
        let overlayLoaded = false;

        // Timeout fallback - if images don't load in 10 seconds, fail
        const timeout = setTimeout(() => {
          URL.revokeObjectURL(mainUrl);
          URL.revokeObjectURL(overlayUrl);
          reject(new Error(`Image loading timeout - main: ${mainFormat}, overlay: ${overlayFormat}`));
        }, 10000);

        function tryMerge() {
          if (!mainLoaded || !overlayLoaded) return;

          clearTimeout(timeout);

          try {
            // Validate dimensions
            if (!mainImg.width || !mainImg.height || !overlayImg.width || !overlayImg.height) {
              throw new Error(`Invalid image dimensions - main: ${mainImg.width}x${mainImg.height}, overlay: ${overlayImg.width}x${overlayImg.height}`);
            }

            // Create canvas with main image dimensions
            const canvas = document.createElement("canvas");
            canvas.width = mainImg.width;
            canvas.height = mainImg.height;
            const ctx = canvas.getContext("2d");

            if (!ctx) {
              throw new Error("Failed to get 2D context from canvas");
            }

            // Draw main image
            ctx.drawImage(mainImg, 0, 0);

            // Draw overlay on top (scaled if needed)
            ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);

            // Convert to blob
            canvas.toBlob(
              (blob) => {
                if (!blob) {
                  URL.revokeObjectURL(mainUrl);
                  URL.revokeObjectURL(overlayUrl);
                  reject(new Error("Canvas toBlob failed - returned null"));
                  return;
                }

                // Clean up URLs
                URL.revokeObjectURL(mainUrl);
                URL.revokeObjectURL(overlayUrl);

                // Convert blob to arraybuffer
                blob.arrayBuffer().then(resolve).catch(reject);
              },
              "image/jpeg",
              0.95
            );
          } catch (error) {
            URL.revokeObjectURL(mainUrl);
            URL.revokeObjectURL(overlayUrl);
            reject(error);
          }
        }

        mainImg.onload = () => {
          mainLoaded = true;
          tryMerge();
        };
        mainImg.onerror = (event) => {
          clearTimeout(timeout);
          URL.revokeObjectURL(mainUrl);
          URL.revokeObjectURL(overlayUrl);
          reject(new Error(`Failed to load main image (${mainFormat}) - browser rejected format or corrupt data`));
        };

        overlayImg.onload = () => {
          overlayLoaded = true;
          tryMerge();
        };
        overlayImg.onerror = (event) => {
          clearTimeout(timeout);
          URL.revokeObjectURL(mainUrl);
          URL.revokeObjectURL(overlayUrl);
          reject(new Error(`Failed to load overlay image (${overlayFormat}) - browser rejected format or corrupt data`));
        };

        mainImg.src = mainUrl;
        overlayImg.src = overlayUrl;
      });
    }

    /**
     * Get MIME type from file extension
     */
    function getImageMimeType(ext) {
      if (!ext) return null;
      const extLower = ext.toLowerCase().replace('.', '');
      const mimeMap = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'webp': 'image/webp',
        'bmp': 'image/bmp',
        'tiff': 'image/tiff',
        'tif': 'image/tiff'
      };
      return mimeMap[extLower] || null;
    }

    /**
     * Convert any image format to PNG using Canvas API
     * This ensures FFmpeg.wasm compatibility (WebP, JPEG, etc. ‚Üí PNG)
     * @param {ArrayBuffer} imageData - Image data in any format
     * @param {string} originalExt - Original file extension (for logging)
     * @returns {Promise<ArrayBuffer>} - PNG image data
     */
    async function convertImageToPNG(imageData, originalExt) {
      return new Promise((resolve, reject) => {
        const blob = new Blob([imageData]);
        const url = URL.createObjectURL(blob);
        const img = new Image();

        img.onload = () => {
          try {
            // Create canvas matching image dimensions
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;

            // Draw image to canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            // Convert to PNG blob
            canvas.toBlob((pngBlob) => {
              if (!pngBlob) {
                URL.revokeObjectURL(url);
                reject(new Error('Failed to create PNG blob'));
                return;
              }

              // Convert blob to ArrayBuffer
              pngBlob.arrayBuffer().then(arrayBuffer => {
                URL.revokeObjectURL(url);
                resolve(arrayBuffer);
              }).catch(err => {
                URL.revokeObjectURL(url);
                reject(err);
              });
            }, 'image/png', 1.0); // Full quality PNG

          } catch (error) {
            URL.revokeObjectURL(url);
            reject(error);
          }
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error(`Failed to load image as ${originalExt}`));
        };

        img.src = url;
      });
    }

    /**
     * Merge overlay video on top of main video using FFmpeg.wasm
     *
     * This is the slowest operation in the web version (1-5 minutes per video).
     * FFmpeg.wasm runs in WebAssembly, which is slower than native FFmpeg.
     *
     * Process:
     * 1. Write input files to FFmpeg's virtual filesystem (in-memory)
     * 2. Convert image overlays to PNG (FFmpeg.wasm compatibility)
     * 3. Probe main video dimensions for proper overlay scaling
     * 4. Execute FFmpeg with filter chain to composite overlay
     * 5. Read output from virtual filesystem
     * 6. CRITICAL: Extract data correctly (see return statement)
     * 7. Clean up virtual filesystem
     *
     * FFmpeg Filter Strategies:
     * - Image overlay: Loop image infinitely, scale to video size, center
     * - Video overlay: Simplified filter (complex filters cause black screens in WASM)
     * - Firefox: Use veryfast preset (known WASM compatibility issues)
     *
     * Common Failures:
     * - Output < 1000 bytes: Encoding failure
     * - Black screen: Filter too complex for WASM or Firefox browser
     * - Memory error: Need to reset FFmpeg instance
     * - "Media Offline": Corrupted output due to incorrect buffer extraction (FIXED)
     *
     * @param {ArrayBuffer} mainData - Main video data
     * @param {ArrayBuffer} overlayData - Overlay video/image data
     * @param {Function} progressCallback - Optional progress callback (receives percentage)
     * @param {boolean} overlayIsImage - True if overlay is image (png/jpg), False if video
     * @param {string} overlayExt - Overlay file extension (e.g., '.mp4', '.png')
     * @returns {Promise<ArrayBuffer>} - Merged video data
     */
    async function mergeVideoOverlay(
      mainData,
      overlayData,
      progressCallback,
      overlayIsImage = false,
      overlayExt = '.mp4'
    ) {
      const ffmpeg = await initFFmpeg(); // Will auto-reset if needed (memory management)

      if (!ffmpeg) {
        throw new Error("FFmpeg.wasm not available");
      }

      let overlayFilename;
      try {
        // Write input files to FFmpeg's in-memory virtual filesystem
        // FFmpeg.wasm doesn't access real filesystem, uses virtual FS for security
        await ffmpeg.writeFile("main.mp4", new Uint8Array(mainData));

        // Convert image overlays to PNG for FFmpeg.wasm compatibility
        if (overlayIsImage) {
          addLog(`  Converting ${overlayExt} overlay to PNG for FFmpeg compatibility...`, 'info', 'ffmpeg');
          try {
            const pngData = await convertImageToPNG(overlayData, overlayExt);
            overlayFilename = 'overlay.png';
            await ffmpeg.writeFile(overlayFilename, new Uint8Array(pngData));
            addLog('  ‚úì Overlay converted to PNG', 'success', 'ffmpeg');
          } catch (convertError) {
            addLog(`  Warning: PNG conversion failed, using original format: ${convertError.message}`, 'warning', 'ffmpeg');
            overlayFilename = `overlay${overlayExt}`;
            await ffmpeg.writeFile(overlayFilename, new Uint8Array(overlayData));
          }
        } else {
          overlayFilename = 'overlay.mp4';
          await ffmpeg.writeFile(overlayFilename, new Uint8Array(overlayData));
        }

        // Set up progress logging
        ffmpeg.on("progress", ({ progress }) => {
          if (progressCallback) {
            const percent = Math.round(progress * 100);
            progressCallback(percent);
            addLog(`Encoding progress: ${percent}%`, 'ffmpeg', 'ffmpeg');
          }
        });

        // Probe main video to get dimensions to properly scale overlay
        let mainWidth = null;
        let mainHeight = null;
        try {
          const probeRaw = await ffmpeg.ffprobe([
            "-v",
            "error",
            "-select_streams",
            "v:0",
            "-show_entries",
            "stream=width,height",
            "-of",
            "json",
            "main.mp4",
          ]);
          try {
            const probeJson = JSON.parse(probeRaw);
            if (probeJson.streams && probeJson.streams[0]) {
              mainWidth = probeJson.streams[0].width;
              mainHeight = probeJson.streams[0].height;
            }
          } catch (e) {
            // If parse fails, try regex parse fallback
            try {
              const matchW = probeRaw.match(/"width"\s*:\s*(\d+)/);
              const matchH = probeRaw.match(/"height"\s*:\s*(\d+)/);
              if (matchW) mainWidth = parseInt(matchW[1], 10);
              if (matchH) mainHeight = parseInt(matchH[1], 10);
            } catch (e2) {
              // Ignore
            }
          }
        } catch (probeError) {
          addLog(`    FFprobe failed: ${(probeError && probeError.message) || String(probeError)}`, "info");
          console.warn('FFprobe failed:', probeError);
        }

        if (mainWidth && mainHeight) {
          addLog(`    main video dimensions: ${mainWidth}x${mainHeight}`, 'info');
        }

        // FFmpeg command arguments ‚Äî handle image overlay vs video overlay
        let args;
        if (overlayIsImage) {
          // overlay is an image (png/jpg/etc.)
          let scaleStr = '';
          if (mainWidth && mainHeight) scaleStr = `${mainWidth}:${mainHeight}`;
          else scaleStr = 'iw:ih';
          args = [
            "-i",
            "main.mp4",
            "-loop",
            "1",
            "-i",
            overlayFilename,
            "-filter_complex",
            // Scale overlay to main video and center using explicit dimensions
            `[1:v]scale=${scaleStr}[ovr];[0:v][ovr]overlay=x=(main_w-overlay_w)/2:y=(main_h-overlay_h)/2:format=auto:shortest=1[outv]`,
            "-map",
            "[outv]",
            "-map",
            "0:a?",
            "-c:v",
            "libx264",
            "-preset",
            "ultrafast",
            "-crf",
            "23",
            "-pix_fmt",
            "yuv420p",
            "-c:a",
            "copy",
            "-movflags",
            "+faststart",
            "-y",
            "output.mp4",
          ];
        } else {
          // overlay is a video
          // Detect Firefox and use simpler filter chain
          const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          let filterComplex;
          let preset = "medium";

          // Use SIMPLEST possible filter for ALL browsers
          // Complex filters (fps, setsar, loop, setpts) cause black screen in WASM FFmpeg
          addLog('  Using simplified filter chain for WASM compatibility', 'info', 'ffmpeg');

          if (mainWidth && mainHeight) {
            // We have dimensions - use them
            filterComplex = `[1:v]scale=${mainWidth}:${mainHeight}[ovr];[0:v][ovr]overlay=shortest=1[outv]`;
            addLog(`  Scaling overlay to ${mainWidth}x${mainHeight}`, 'info', 'ffmpeg');
          } else {
            // No dimensions - overlay keeps its size
            filterComplex = `[0:v][1:v]overlay=shortest=1[outv]`;
            addLog('  Using overlay at original size (no scaling)', 'warning', 'ffmpeg');
          }

          preset = isFirefox ? "veryfast" : "medium";

          args = [
            "-i",
            "main.mp4",
            "-i",
            overlayFilename,
            "-filter_complex",
            filterComplex,
            "-map",
            "[outv]", // Map the filtered video output
            "-map",
            "0:a?", // Map audio from main video
            "-c:v",
            "libx264",
            "-preset",
            preset,
            "-crf",
            "23",
            "-pix_fmt",
            "yuv420p",
            "-c:a",
            "copy",
            "-movflags",
            "+faststart",
            "-shortest", // Stop at shortest input
            "-y",
            "output.mp4",
          ];
        }

        // Execute FFmpeg
        addLog(`Starting video merge (overlay type: ${overlayIsImage ? 'image' : 'video'})`, 'info', 'ffmpeg');
        addLog(`FFmpeg command: ${args.join(' ')}`, 'ffmpeg', 'ffmpeg');

        try {
          await ffmpeg.exec(args);
          addLog('Video merge completed successfully', 'success', 'ffmpeg');
        } catch (execError) {
          addLog(`FFmpeg execution error: ${execError.message || String(execError)}`, 'error', 'ffmpeg');
          throw new Error(`FFmpeg execution failed: ${execError.message || String(execError)}`);
        }

        // Read output file
        const outputData = await ffmpeg.readFile("output.mp4");

        // Validate output size
        if (outputData.byteLength < 1000) {
          addLog(`WARNING: Output video is suspiciously small (${outputData.byteLength} bytes)`, 'error', 'ffmpeg');
          throw new Error(`Output video too small: ${outputData.byteLength} bytes - likely encoding failure`);
        }

        addLog(`Output video size: ${formatBytes(outputData.byteLength)}`, 'success', 'ffmpeg');

        // Clean up virtual filesystem
        await ffmpeg.deleteFile("main.mp4").catch(() => {});
        if (overlayFilename) await ffmpeg.deleteFile(overlayFilename).catch(() => {});
        await ffmpeg.deleteFile("output.mp4").catch(() => {});

        // Remove progress listener
        ffmpeg.off("progress");

        // Increment success counter for memory management tracking
        videosProcessedSinceReset++;
        totalVideosProcessed++;

        // Convert Uint8Array to ArrayBuffer
        // CRITICAL BUG FIX: Must use .slice().buffer, NOT .buffer directly!
        //
        // Why this matters:
        // - FFmpeg.readFile() returns a Uint8Array that may be a VIEW into a larger ArrayBuffer
        // - Using .buffer directly returns the ENTIRE underlying ArrayBuffer (with garbage data)
        // - This creates corrupted video files with extra bytes at the end
        // - Video players show "Media Offline" error due to invalid data after video stream
        //
        // Solution:
        // - .slice() creates NEW Uint8Array with ONLY the valid data (no excess buffer)
        // - .buffer then extracts the clean ArrayBuffer
        //
        // Example:
        // outputData = Uint8Array(1000 bytes) backed by ArrayBuffer(4096 bytes)
        // outputData.buffer ‚Üí 4096 bytes (WRONG! Has 3096 bytes of garbage)
        // outputData.slice().buffer ‚Üí 1000 bytes (CORRECT! Only video data)
        return outputData.slice().buffer;
      } catch (error) {
        // Clean up on error
        try {
          await ffmpeg.deleteFile("main.mp4").catch(() => { });
          if (overlayFilename) await ffmpeg.deleteFile(overlayFilename).catch(() => { });
          await ffmpeg.deleteFile("output.mp4").catch(() => { });
          ffmpeg.off("progress");
        } catch (cleanupError) {
          // Ignore cleanup errors
        }

        // Normalize error message
        let errorMsg = "";
        try {
          errorMsg = error && (error.message || String(error) || JSON.stringify(error));
        } catch (e) {
          errorMsg = "Unknown error";
        }

        // Check for memory-related errors - force FFmpeg reset
        if (errorMsg.includes('memory access out of bounds') ||
            errorMsg.includes('RuntimeError') ||
            errorMsg.includes('detached')) {
          addLog('  CRITICAL: FFmpeg memory error detected during merge, forcing reset...', 'error');
          console.error("FFmpeg memory error during merge:", error);
        } else {
          addLog('  Video merge failed, resetting FFmpeg for next attempt', 'info');
        }

        // On error, terminate FFmpeg instance to ensure clean state for next video
        await terminateFFmpeg();
        videosProcessedSinceReset = 0;

        const enhanced = new Error(`FFmpeg merge failed: ${errorMsg}`);
        if (error && error.stack) enhanced.stack = error.stack;
        throw enhanced;
      }
    }

    // Drag and drop handlers
    uploadSection.addEventListener("dragover", (e) => {
      e.preventDefault();
      uploadSection.classList.add("dragover");
    });

    uploadSection.addEventListener("dragleave", () => {
      uploadSection.classList.remove("dragover");
    });

    uploadSection.addEventListener("drop", (e) => {
      e.preventDefault();
      uploadSection.classList.remove("dragover");
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFile(files[0]);
      }
    });

    fileInput.addEventListener("change", (e) => {
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });

    metadataInput.addEventListener("change", async (e) => {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        metadataFileName.textContent = file.name;
        try {
          const text = await file.text();
          const parsed = JSON.parse(text);

          // Support both old format (array) and new format (object with settings)
          if (Array.isArray(parsed)) {
            // Old format: just the memories array
            existingMetadata = parsed;
            existingSettings = null;
          } else if (parsed.memories && Array.isArray(parsed.memories)) {
            // New format: object with memories and settings
            existingMetadata = parsed.memories;
            existingSettings = parsed.settings || null;
          } else {
            throw new Error("Invalid metadata.json format");
          }

          addLog(
            `Loaded metadata.json with ${existingMetadata.length} entries`,
            "success"
          );

          // Restore settings to UI if they exist
          if (existingSettings) {
            document.getElementById("mergeOverlaysCheckbox").checked = existingSettings.mergeOverlays || false;
            document.getElementById("deferVideoOverlaysCheckbox").checked = existingSettings.deferVideoOverlays || false;
            document.getElementById("overlaysOnlyCheckbox").checked = existingSettings.overlaysOnly || false;
            document.getElementById("videosOnlyCheckbox").checked = existingSettings.videosOnly || false;
            document.getElementById("picturesOnlyCheckbox").checked = existingSettings.picturesOnly || false;
            document.getElementById("timestampFilenamesCheckbox").checked = existingSettings.timestampFilenames || false;
            document.getElementById("batchSizeSelect").value = existingSettings.batchSize || "50";
            document.getElementById("ffmpegResetIntervalSelect").value = existingSettings.ffmpegResetInterval || "5";
            document.getElementById("rateLimitDelaySelect").value = existingSettings.rateLimitDelay || "500";
            addLog("Restored settings from metadata.json", "info");
          }

          // Enable start button for metadata-only resume (no HTML required)
          const pending = existingMetadata.filter(m =>
            m.status === 'pending' || m.status === 'in_progress' || m.status === 'failed'
          ).length;
          const success = existingMetadata.filter(m => m.status === 'success').length;

          addLog(
            `Status: ${success} completed, ${pending} to download/retry`,
            "info"
          );
          addLog(
            'Ready to resume! Click "Start Download" button when ready.',
            "info"
          );

          // Show the start button (allow resuming without HTML)
          startButton.style.display = "inline-block";
        } catch (error) {
          addLog(`Error loading metadata.json: ${error.message}`, "error");
          existingMetadata = null;
          existingSettings = null;
        }
      }
    });

    /**
     * Add log entry to appropriate tab
     * @param {string} message - Log message
     * @param {string} type - Log type: info, success, error, warning, ffmpeg
     * @param {string} tab - Which tab: 'main' or 'ffmpeg'
     */
    function addLog(message, type = "info", tab = "main") {
      const logContainer = tab === "ffmpeg" ? document.getElementById("logFFmpeg") : document.getElementById("log");
      const entry = document.createElement("div");
      entry.className = `log-entry ${type}`;
      entry.textContent = message;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    /**
     * Switch between log tabs
     */
    function switchLogTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.log-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');

      // Update content
      document.querySelectorAll('.log-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`log-${tabName}`).classList.add('active');
    }

    /**
     * Copy all logs to clipboard for easy sharing/debugging
     */
    async function copyLogsToClipboard() {
      const mainLogEntries = document.querySelectorAll('#log .log-entry');
      const ffmpegLogEntries = document.querySelectorAll('#logFFmpeg .log-entry');

      let logText = '=== MAIN ACTIVITY LOG ===\n';
      logText += Array.from(mainLogEntries).map(entry => entry.textContent).join('\n');

      if (ffmpegLogEntries.length > 0) {
        logText += '\n\n=== FFMPEG DETAILS ===\n';
        logText += Array.from(ffmpegLogEntries).map(entry => entry.textContent).join('\n');
      }

      try {
        await navigator.clipboard.writeText(logText);

        // Visual feedback
        const btn = document.getElementById('copyLogsBtn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '‚úÖ Copied!';
        btn.style.background = '#28a745';

        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.style.background = '#667eea';
        }, 2000);

        addLog('Logs copied to clipboard!', 'success');
      } catch (err) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = logText;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();

        try {
          document.execCommand('copy');
          addLog('Logs copied to clipboard!', 'success');

          const btn = document.getElementById('copyLogsBtn');
          const originalText = btn.innerHTML;
          btn.innerHTML = '‚úÖ Copied!';
          btn.style.background = '#28a745';

          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        } catch (e) {
          addLog('Failed to copy logs. Please select and copy manually.', 'error');
        }

        document.body.removeChild(textarea);
      }
    }

    function updateProgress(current, total) {
      const percent = Math.round((current / total) * 100);
      progressFill.style.width = `${percent}%`;
      progressFill.textContent = `${percent}%`;
      status.textContent = `Processing ${current} of ${total} memories...`;
    }

    async function handleFile(file) {
      if (!file.name.endsWith(".html")) {
        alert("Please upload an HTML file");
        return;
      }

      fileName.textContent = file.name;
      addLog("Reading file...", "info");

      const text = await file.text();
      parseHTML(text);
    }

    function parseHTML(htmlText) {
      addLog("Parsing HTML...", "info");

      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlText, "text/html");
      const rows = doc.querySelectorAll("tr");

      memories = [];

      rows.forEach((row) => {
        const cells = row.querySelectorAll("td");
        if (cells.length >= 4) {
          const dateCell = cells[0].textContent.trim();
          const typeCell = cells[1].textContent.trim();
          const locationCell = cells[2].textContent.trim();
          const link = cells[3].querySelector("a");

          if (dateCell.includes("UTC") && link) {
            const onclickAttr = link.getAttribute("onclick");
            const urlMatch = onclickAttr
              ? onclickAttr.match(/downloadMemories\('([^']+)'/)
              : null;

            if (urlMatch) {
              const locationMatch = locationCell.match(
                /Latitude, Longitude:\s*([-\d.]+),\s*([-\d.]+)/
              );

              memories.push({
                date: dateCell,
                mediaType: typeCell,
                latitude: locationMatch ? locationMatch[1] : "Unknown",
                longitude: locationMatch ? locationMatch[2] : "Unknown",
                url: urlMatch[1],
              });
            }
          }
        }
      });

      if (memories.length === 0) {
        addLog("No memories found in file!", "error");
        alert(
          "No memories found in the HTML file. Please make sure you uploaded the correct memories_history.html file."
        );
        return;
      }

      addLog(`Found ${memories.length} memories`, "success");
      addLog(
        'Ready to download! Click the "Start Download" button when ready.',
        "info"
      );

      // Show the start button
      startButton.style.display = "inline-block";
    }

    function handleStartDownload() {
      // Reset stop flag
      shouldStop = false;

      // Hide start button, show stop button and progress
      startButton.style.display = "none";
      stopButton.style.display = "inline-block";
      progressContainer.style.display = "block";

      // Start the download
      startDownload();
    }

    function handleStopDownload() {
      // Set stop flag
      shouldStop = true;
      addLog("\n‚è∏ Stop requested - will save progress after current item completes...", "warning");

      // Disable stop button to prevent multiple clicks
      stopButton.disabled = true;
      stopButton.textContent = "‚è∏ Stopping...";
      stopButton.style.opacity = "0.6";
    }

    async function finalizeAndDownload(metadataList, label = "stopped") {
      // Create final ZIP with metadata
      const finalZip = new JSZip();
      const metadataWithSettings = {
        settings: captureCurrentSettings(),
        memories: metadataList
      };
      finalZip.file("metadata.json", JSON.stringify(metadataWithSettings, null, 2));

      const filename = `snapchat-memories-${label}.zip`;
      status.textContent = `Creating ${filename}...`;
      addLog(`\nüì¶ Packaging ${filename}...`, "info");

      let zipBlob;
      try {
        zipBlob = await finalZip.generateAsync({ type: "blob" });
      } catch (error) {
        // Handle memory allocation failures
        if (error instanceof RangeError || error.message?.includes('allocation')) {
          addLog(`‚ùå ERROR: Out of memory creating ${filename}`, "error");
          addLog(`  This should not happen for metadata-only ZIP`, "error");
          throw new Error(`Memory allocation failed: ${error.message}`);
        }
        throw error; // Re-throw other errors
      }

      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      addLog(`‚úÖ Progress saved to ${filename}`, "success");
      addLog("You can resume later by uploading this metadata.json file", "info");

      // Reset UI
      stopButton.style.display = "none";
      stopButton.disabled = false;
      stopButton.textContent = "üõë Stop & Save Progress";
      stopButton.style.opacity = "1";
      startButton.style.display = "inline-block";
      shouldStop = false;
    }

    async function startDownload() {
      currentIndex = 0;
      deferredVideoOverlays = []; // Clear deferred videos from previous runs
      shouldStop = false; // Reset stop flag

      // Capture timestamp filename setting
      const useTimestampFilenames = document.getElementById("timestampFilenamesCheckbox").checked;

      // Initialize metadata by matching existing metadata with freshly parsed memories
      let metadataList = [];
      currentMetadataList = []; // Reset global tracking

      // Check if we're in metadata-only mode (resume without HTML)
      const metadataOnlyMode = existingMetadata && (!memories || memories.length === 0);

      if (metadataOnlyMode) {
        // Metadata-only resume: use existing metadata directly
        metadataList = existingMetadata;
        addLog(
          "Resuming from metadata.json (HTML file not required)",
          "info"
        );
        addLog(
          "Will skip successful downloads and retry failed/pending items",
          "info"
        );
      } else if (!existingMetadata) {
        // No existing metadata: create new entries with pending status
        for (let i = 0; i < memories.length; i++) {
          const memory = memories[i];
          metadataList.push({
            number: i + 1,
            date: memory.date,
            media_type: memory.mediaType,
            latitude: memory.latitude,
            longitude: memory.longitude,
            url: memory.url,
            status: "pending",
            files: [],
          });
        }
        addLog("Initialized metadata for all memories", "info");
      } else {
        // Existing metadata provided: match with current memories by URL
        // This handles cases where new memories were added or order changed
        addLog(
          "Merging existing metadata with current HTML parse...",
          "info"
        );

        // Create a map of existing metadata by URL for fast lookup
        const existingByUrl = new Map();
        existingMetadata.forEach((meta) => {
          existingByUrl.set(meta.url, meta);
        });

        // Process all memories from current HTML parse
        let newCount = 0;
        let mergedCount = 0;
        for (let i = 0; i < memories.length; i++) {
          const memory = memories[i];
          const existing = existingByUrl.get(memory.url);

          if (existing) {
            // Memory exists in metadata: preserve status and files
            metadataList.push({
              number: i + 1,
              date: memory.date,
              media_type: memory.mediaType,
              latitude: memory.latitude,
              longitude: memory.longitude,
              url: memory.url,
              status: existing.status || "pending",
              files: existing.files || [],
              error: existing.error, // Preserve error if it exists
            });
            mergedCount++;
          } else {
            // New memory not in metadata: add as pending
            metadataList.push({
              number: i + 1,
              date: memory.date,
              media_type: memory.mediaType,
              latitude: memory.latitude,
              longitude: memory.longitude,
              url: memory.url,
              status: "pending",
              files: [],
            });
            newCount++;
          }
        }

        addLog(
          `Merged ${mergedCount} existing entries, added ${newCount} new entries`,
          "info"
        );
        addLog(
          "Will skip successful downloads and retry failed/pending items",
          "info"
        );
      }

      // Check media type filters
      const videosOnly =
        document.getElementById("videosOnlyCheckbox").checked;
      const picturesOnly = document.getElementById(
        "picturesOnlyCheckbox"
      ).checked;

      // Determine which items to download
      let itemsToDownload = metadataList.map((m, i) => ({
        metadata: m,
        index: i,
      }));

      // First, skip successfully downloaded items (applies to all modes)
      const beforeStatusFilter = itemsToDownload.length;
      itemsToDownload = itemsToDownload.filter(
        (item) =>
          item.metadata.status !== "success" ||
          !item.metadata.files ||
          item.metadata.files.length === 0
      );
      const afterStatusFilter = itemsToDownload.length;

      addLog(
        `${afterStatusFilter} items to download (${beforeStatusFilter - afterStatusFilter} already completed)`,
        "info"
      );

      // Then apply media type filters if enabled
      if (videosOnly) {
        const beforeMediaFilter = itemsToDownload.length;
        itemsToDownload = itemsToDownload.filter(
          (item) => item.metadata.media_type === "Video"
        );
        addLog(
          `Videos-only filter: ${itemsToDownload.length} videos to process (${beforeMediaFilter - itemsToDownload.length} pictures skipped)`,
          "info"
        );
      } else if (picturesOnly) {
        const beforeMediaFilter = itemsToDownload.length;
        itemsToDownload = itemsToDownload.filter(
          (item) => item.metadata.media_type === "Image"
        );
        addLog(
          `Pictures-only filter: ${itemsToDownload.length} pictures to process (${beforeMediaFilter - itemsToDownload.length} videos skipped)`,
          "info"
        );
      }

      if (itemsToDownload.length === 0) {
        addLog("All applicable items already downloaded!", "success");
        status.textContent = "All downloads complete!";
        progressFill.style.width = "100%";
        progressFill.textContent = "100%";
        return;
      }

      // Store metadata list globally for stop functionality
      currentMetadataList = metadataList;

      // Get batch size
      const batchSize = parseInt(
        document.getElementById("batchSizeSelect").value
      );
      const useBatching = batchSize > 0;

      if (useBatching) {
        const numBatches = Math.ceil(itemsToDownload.length / batchSize);
        addLog(
          `Will create ${numBatches} batch(es) of up to ${batchSize} files each`,
          "info"
        );

        // Process in batches
        for (let batchNum = 0; batchNum < numBatches; batchNum++) {
          const batchStart = batchNum * batchSize;
          const batchEnd = Math.min(
            batchStart + batchSize,
            itemsToDownload.length
          );
          const batchItems = itemsToDownload.slice(batchStart, batchEnd);

          addLog(
            `\nProcessing Batch ${batchNum + 1}/${numBatches} (${batchItems.length
            } items)`,
            "info"
          );

          await processBatch(
            batchItems,
            metadataList,
            batchNum + 1,
            batchStart,
            itemsToDownload.length,
            useTimestampFilenames
          );
        }
      } else {
        // Process all at once
        addLog("Processing all items in a single ZIP", "info");
        await processBatch(
          itemsToDownload,
          metadataList,
          0,
          0,
          itemsToDownload.length,
          useTimestampFilenames
        );
      }

      // Process deferred video overlays
      if (deferredVideoOverlays.length > 0) {
        addLog(`\n‚è≥ Processing ${deferredVideoOverlays.length} deferred video overlay(s)...`, "info");
        await processDeferredVideoOverlays(metadataList, useTimestampFilenames);
      }

      // Final summary
      const successful = metadataList.filter(
        (m) => m.status === "success"
      ).length;
      const failed = metadataList.filter((m) => m.status === "failed").length;
      const pending = metadataList.filter(
        (m) => m.status === "pending"
      ).length;

      addLog(
        `\n‚úì Complete! ${successful} successful, ${failed} failed, ${pending} pending`,
        "success"
      );

      if (failed > 0 || pending > 0) {
        addLog(
          `Tip: Upload metadata.json (no HTML required) to retry failed/pending items`,
          "info"
        );
      }

      status.textContent = "All downloads complete!";
      progressFill.style.width = "100%";
      progressFill.textContent = "100%";
    }

    /**
     * Process a batch of items with ZERO video memory accumulation
     *
     * STRATEGY: As soon as we encounter a video needing merge:
     * 1. Download current batch (all items processed so far)
     * 2. Process video individually in its own ZIP
     * 3. Continue with fresh batch
     *
     * This ensures merged videos NEVER accumulate in memory.
     */
    async function processBatch(
      batchItems,
      metadataList,
      batchNum,
      globalStartIndex,
      totalItems,
      useTimestampFilenames
    ) {
      zip = new JSZip();
      let subBatchNum = 0;
      let itemsInCurrentZip = 0;

      const mergeEnabled = document.getElementById('mergeOverlaysCheckbox').checked;
      const rateLimitDelay = parseInt(document.getElementById('rateLimitDelaySelect')?.value || '500', 10);

      addLog(`Batch ${batchNum}: ${batchItems.length} items to process`, 'info');
      if (rateLimitDelay > 0) {
        addLog(`  Rate limiting: ${rateLimitDelay}ms delay between downloads (prevents AWS 500 errors)`, 'info');
      }

      for (let i = 0; i < batchItems.length; i++) {
        // Check if stop was requested
        if (shouldStop) {
          addLog(`\n‚è∏ Stopping after processing ${i} of ${batchItems.length} items in this batch`, 'warning');
          if (itemsInCurrentZip > 0) {
            addLog(`  Saving ${itemsInCurrentZip} items processed so far...`, 'info');
            await downloadCurrentBatch(metadataList, batchNum, subBatchNum, 'partial');
          }
          await finalizeAndDownload(metadataList, 'stopped');
          return;
        }

        const item = batchItems[i];
        const globalCount = globalStartIndex + i + 1;

        // Rate limiting: Add delay between downloads to avoid AWS/Snapchat CDN limits
        if (i > 0) {  // Skip delay for first item
          const rateLimitDelay = parseInt(document.getElementById('rateLimitDelaySelect')?.value || '500', 10);
          if (rateLimitDelay > 0) {
            await new Promise(resolve => setTimeout(resolve, rateLimitDelay));
          }
        }

        // Process the item and check if it merged a video overlay immediately
        const result = await processItem(item, globalCount, totalItems, metadataList, useTimestampFilenames);
        itemsInCurrentZip++;

        // If a video overlay was merged immediately (not deferred), download it in its own ZIP
        // This ensures merged videos never accumulate in memory
        if (result.mergedVideoImmediately) {
          addLog(`  Downloading merged video individually...`, 'info');
          await downloadCurrentBatch(metadataList, batchNum, subBatchNum, `video-${item.metadata.number}`);
          subBatchNum++;
          zip = new JSZip();
          itemsInCurrentZip = 0;

          // Extra GC time after video
          addLog('  Pausing 2s for garbage collection...', 'info');
          await new Promise(resolve => setTimeout(resolve, 2000));
          checkMemoryUsage();
        }
      }

      // Download any remaining items
      if (itemsInCurrentZip > 0) {
        addLog(`  Downloading final batch (${itemsInCurrentZip} items)...`, 'info');
        await downloadCurrentBatch(metadataList, batchNum, subBatchNum);
      }
    }

    /**
     * Capture current settings from UI
     */
    function captureCurrentSettings() {
      return {
        mergeOverlays: document.getElementById("mergeOverlaysCheckbox").checked,
        deferVideoOverlays: document.getElementById("deferVideoOverlaysCheckbox").checked,
        overlaysOnly: document.getElementById("overlaysOnlyCheckbox").checked,
        videosOnly: document.getElementById("videosOnlyCheckbox").checked,
        picturesOnly: document.getElementById("picturesOnlyCheckbox").checked,
        timestampFilenames: document.getElementById("timestampFilenamesCheckbox").checked,
        batchSize: document.getElementById("batchSizeSelect").value,
        ffmpegResetInterval: document.getElementById("ffmpegResetIntervalSelect").value,
        rateLimitDelay: document.getElementById("rateLimitDelaySelect").value
      };
    }

    /**
     * Download the current ZIP batch
     */
    async function downloadCurrentBatch(metadataList, batchNum, subBatchNum, suffix = '') {
      // Add metadata.json to zip with settings
      const metadataWithSettings = {
        settings: captureCurrentSettings(),
        memories: metadataList
      };
      zip.file("metadata.json", JSON.stringify(metadataWithSettings, null, 2));

      // Generate filename
      let filename;
      if (suffix) {
        filename = `snapchat-memories-batch-${batchNum}-${suffix}.zip`;
      } else if (subBatchNum > 0) {
        filename = `snapchat-memories-batch-${batchNum}-part-${subBatchNum + 1}.zip`;
      } else if (batchNum > 0) {
        filename = `snapchat-memories-batch-${batchNum}.zip`;
      } else {
        filename = "snapchat-memories.zip";
      }

      status.textContent = `Creating ${filename}...`;
      addLog(`  Packaging ${filename}...`, "info");

      let zipBlob;
      try {
        zipBlob = await zip.generateAsync(
          { type: "blob" },
          (metadata) => {
            const percent = Math.round(metadata.percent);
            progressFill.style.width = `${percent}%`;
            progressFill.textContent = `${percent}%`;
          }
        );
      } catch (error) {
        // Handle memory allocation failures
        if (error instanceof RangeError || error.message?.includes('allocation')) {
          addLog(`‚ùå ERROR: Out of memory creating ${filename}`, "error");
          addLog(`  Browser ran out of memory packaging this batch`, "error");
          addLog(`  üí° SOLUTION: Reduce batch size in settings (try 10 or 20 items)`, "warning");
          addLog(`  üí° Or enable "Defer video overlays" to reduce memory usage`, "warning");
          throw new Error(`Memory allocation failed: ${error.message}. Try reducing batch size.`);
        }
        throw error; // Re-throw other errors
      }

      // Download the ZIP file
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      addLog(`  ‚úì Downloaded: ${filename} (${formatBytes(zipBlob.size)})`, "success");
    }

    /**
     * Process all deferred video overlays after main download completes.
     *
     * DEFERRED PROCESSING PATTERN - Critical for memory management:
     *
     * Why defer video overlay processing?
     * 1. Video merging with FFmpeg.wasm is SLOW (1-5 minutes per video)
     * 2. Merging during download blocks other downloads (lost time)
     * 3. FFmpeg.wasm accumulates memory that can't be released mid-download
     * 4. Browser may run out of memory before downloads complete
     *
     * Deferred approach:
     * - Phase 1: Download all content quickly (main + overlay files saved separately)
     * - Phase 2: Process video merges in batch (user can pause/resume)
     * - Each merged video downloads as separate ZIP immediately (prevents memory buildup)
     * - 2-second GC pause between videos (allows browser to recover memory)
     *
     * Trade-offs:
     * + Uninterrupted downloading (no 5-minute pauses per video)
     * + Better memory management (can reset FFmpeg between videos)
     * + User can stop/resume overlay processing separately
     * - Temporarily uses more disk space (main + overlay files kept until merge)
     * - User gets multiple ZIP files instead of one
     *
     * Memory management during deferred processing:
     * - FFmpeg instance auto-resets every N videos (configurable)
     * - Each video downloads in own ZIP immediately (frees RAM)
     * - 2-second pause between videos for garbage collection
     * - Memory warnings if Chrome detects >60% usage
     */
    async function processDeferredVideoOverlays(metadataList, useTimestampFilenames) {
      const total = deferredVideoOverlays.length;

      for (let i = 0; i < total; i++) {
        // Check if stop was requested
        if (shouldStop) {
          addLog(`\n‚è∏ Stopping deferred video processing after ${i} of ${total} videos`, 'warning');
          await finalizeAndDownload(metadataList, 'stopped');
          return;
        }

        const item = deferredVideoOverlays[i];
        const { metadata, fileNum, files, innerZip } = item;
        const extension = ".mp4";

        addLog(`\n[${i + 1}/${total}] Processing deferred video #${metadata.number}`, "info");

        try {
          // Extract main and overlay files from the ZIP we saved earlier
          let mainData = null;
          let overlayData = null;
          let mainName = null;
          let overlayName = null;

          for (const filename of files) {
            const fileData = await innerZip.files[filename].async("arraybuffer");
            if (filename.toLowerCase().includes("overlay")) {
              overlayData = fileData;
              overlayName = filename;
            } else {
              mainData = fileData;
              mainName = filename;
            }
          }

          if (mainData && overlayData) {
            // Determine overlay extension and whether it's an image
            let overlayExt = overlayName && overlayName.includes('.')
              ? overlayName.substring(overlayName.lastIndexOf('.'))
              : null;
            const detectedOverlayExt = detectFileExtension(new Uint8Array(overlayData));
            if (detectedOverlayExt) overlayExt = detectedOverlayExt;
            if (!overlayExt) overlayExt = '.mp4';
            const overlayExtNoDot = overlayExt.replace('.', '').toLowerCase();
            // Treat WebP and GIF as video to preserve animation frames
            // Static images: PNG, JPG, JPEG only
            const overlayIsImage = ['png', 'jpg', 'jpeg'].includes(overlayExtNoDot);

            addLog(`  Merging video overlay (this may take a minute)...`, "info");

            // Merge videos using FFmpeg.wasm
            let mergedData = await mergeVideoOverlay(
              mainData,
              overlayData,
              (progress) => {
                addLog(`    Video merge progress: ${progress}%`, "info");
              },
              overlayIsImage,
              overlayExt
            );

            // Add GPS and timestamp metadata to merged video
            mergedData = await addVideoMetadata(
              mergedData,
              metadata.date,
              metadata.latitude,
              metadata.longitude
            );

            const filename = generateFilename(metadata.date, extension, useTimestampFilenames, fileNum);

            // Create a new ZIP for this merged video
            const videoZip = new JSZip();
            const fileDate = parseSnapchatDate(metadata.date);
            // Store videos uncompressed to prevent browser playback issues
            videoZip.file(filename, mergedData, { date: fileDate, compression: "STORE" });

            // Update metadata with merged file
            metadata.files = [{
              path: filename,
              size: mergedData.byteLength,
              type: "merged",
            }];

            // Add metadata.json with settings
            const metadataWithSettings = {
              settings: captureCurrentSettings(),
              memories: metadataList
            };
            videoZip.file("metadata.json", JSON.stringify(metadataWithSettings, null, 2));

            addLog(`  Merged video: ${filename} (${formatBytes(mergedData.byteLength)})`, "success");

            // Download the merged video ZIP
            const zipFilename = `snapchat-memories-deferred-video-${metadata.number}.zip`;
            status.textContent = `Creating ${zipFilename}...`;
            addLog(`  Packaging ${zipFilename}...`, "info");

            let zipBlob;
            try {
              zipBlob = await videoZip.generateAsync(
                { type: "blob" },
                (zipMetadata) => {
                  const percent = Math.round(zipMetadata.percent);
                  progressFill.style.width = `${percent}%`;
                  progressFill.textContent = `${percent}%`;
                }
              );
            } catch (error) {
              // Handle memory allocation failures
              if (error instanceof RangeError || error.message?.includes('allocation')) {
                addLog(`‚ùå ERROR: Out of memory creating ${zipFilename}`, "error");
                addLog(`  Browser ran out of memory packaging this video`, "error");
                throw new Error(`Memory allocation failed for video ${metadata.number}: ${error.message}`);
              }
              throw error; // Re-throw other errors
            }

            // Download
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement("a");
            a.href = url;
            a.download = zipFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            addLog(`  ‚úì Downloaded: ${zipFilename} (${formatBytes(zipBlob.size)})`, "success");

            // Pause for GC
            addLog('  Pausing 2s for garbage collection...', 'info');
            await new Promise(resolve => setTimeout(resolve, 2000));
            checkMemoryUsage();
          } else {
            throw new Error("Missing main or overlay video file");
          }
        } catch (error) {
          let errorMsg = "";
          try {
            errorMsg = error && (error.message || String(error) || JSON.stringify(error));
          } catch (e) {
            errorMsg = "Unknown error";
          }

          addLog(`  ERROR: Failed to merge deferred video (${errorMsg})`, "error");
          console.error("Failed to merge deferred video", error);
          if (error && error.stack) {
            addLog(`    Stack: ${error.stack}`, "info");
          }
        }
      }

      // Clear deferred list
      deferredVideoOverlays = [];
      addLog(`\n‚úì Deferred video processing complete!`, "success");
    }

    /**
     * Process a single item (image or video)
     * Extracted from processBatch to support smart batching
     * Returns { mergedVideoImmediately: boolean } to indicate if a video overlay was merged immediately
     */
    async function processItem(batchItem, globalCount, totalItems, metadataList, useTimestampFilenames) {
      const { metadata, index: i } = batchItem;
      const fileNum = String(metadata.number).padStart(2, "0");
      const extension = metadata.media_type === "Video" ? ".mp4" : ".jpg";
      let mergedVideoImmediately = false; // Track if we merged a video overlay immediately

      updateProgress(globalCount, totalItems);
      addLog(
        `[${globalCount}/${totalItems}] #${metadata.number} ${metadata.date} - ${metadata.media_type}`,
        "info"
      );

      // Mark as in progress
      metadata.status = "in_progress";

      try {
        addLog(`    Fetching memory file...`, "info");
        console.log("Fetching:", metadata.url);

        // Retry logic for handling intermittent 500 errors
        const maxRetries = 3;
        let arrayBuffer;
        let lastError;

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            const response = await fetch(metadata.url);

            if (!response.ok) {
              const bodyText = await response.text().catch(() => "<no body>");

              // Retry on 500-series errors (server errors) and 429 (rate limit)
              const shouldRetry = (response.status >= 500 && response.status < 600) || response.status === 429;

              if (shouldRetry && attempt < maxRetries) {
                // Use longer backoff for 500 errors (likely rate limits from AWS)
                // Rate limit backoff: 2s, 5s, 10s
                // Other retryable errors: 1s, 2s, 4s
                const isRateLimit = response.status >= 500;
                const baseDelay = isRateLimit ? 2000 : 1000;
                const maxDelay = isRateLimit ? 10000 : 10000;
                const waitTime = Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);

                const statusHint = isRateLimit ? ' (AWS rate limit)' : '';
                addLog(`    HTTP ${response.status}${statusHint} - Retrying in ${waitTime/1000}s (attempt ${attempt}/${maxRetries})`, "warning");
                console.warn(`HTTP ${response.status} fetching ${metadata.url}, retry ${attempt}/${maxRetries} in ${waitTime}ms`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
                continue; // Retry
              }

              // Non-retryable error or max retries exceeded
              addLog(`    HTTP error ${response.status} while fetching memory file`, "error");
              console.error(`HTTP ${response.status} fetching ${metadata.url}:`, bodyText);
              throw new Error(`HTTP ${response.status}`);
            }

            // Success - get the data
            const blob = await response.blob();
            arrayBuffer = await blob.arrayBuffer();

            if (attempt > 1) {
              addLog(`    ‚úì Download succeeded on attempt ${attempt}`, "success");
            }
            break; // Success, exit retry loop

          } catch (error) {
            lastError = error;

            // Network errors (not HTTP errors) - retry
            if (attempt < maxRetries && !(error.message?.startsWith('HTTP '))) {
              const waitTime = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
              addLog(`    Network error - Retrying in ${waitTime/1000}s (attempt ${attempt}/${maxRetries})`, "warning");
              console.warn(`Network error fetching ${metadata.url}, retry ${attempt}/${maxRetries}:`, error);
              await new Promise(resolve => setTimeout(resolve, waitTime));
              continue; // Retry
            }

            throw error; // Re-throw if max retries or HTTP error
          }
        }

        if (!arrayBuffer) {
          throw lastError || new Error('Download failed after retries');
        }

        // Validate downloaded content
        if (arrayBuffer.byteLength < 100) {
          addLog(
            `    WARNING: Downloaded file is very small (${arrayBuffer.byteLength} bytes) - may be invalid or expired URL`,
            "warning"
          );
        }

        // Check if it's a ZIP file (overlay content)
        const uint8Array = new Uint8Array(arrayBuffer);
        const isZip = uint8Array[0] === 0x50 && uint8Array[1] === 0x4b;

        // Overlays-only filter: Skip memories without overlays
        const overlaysOnly = document.getElementById("overlaysOnlyCheckbox").checked;
        if (overlaysOnly && !isZip) {
          addLog(`  Skipped: No overlay detected (overlays-only mode)`, "info");
          metadata.status = "skipped";
          metadata.skip_reason = "no_overlay";
          return; // Skip this item
        }

        // For videos, check if it looks like a valid MP4 file
        if (
          metadata.media_type === "Video" &&
          !isZip &&
          arrayBuffer.byteLength >= 8
        ) {
          // Check for MP4 magic bytes (ftyp box at bytes 4-8)
          const signature = String.fromCharCode(...uint8Array.slice(4, 8));
          const validSignatures = ["ftyp", "mdat", "moov", "wide"];
          if (!validSignatures.includes(signature)) {
            addLog(
              `    WARNING: File may not be a valid video (invalid MP4 signature)`,
              "warning"
            );
            addLog(
              `    First bytes: ${Array.from(uint8Array.slice(0, 20))
                .map((b) => b.toString(16).padStart(2, "0"))
                .join(" ")}`,
              "warning"
            );
            addLog(
              `    This might be an HTML error page or expired download link`,
              "warning"
            );
          }
        }

        // Reset files array
        metadata.files = [];

        if (isZip) {
            // Extract ZIP contents
            const innerZip = await JSZip.loadAsync(arrayBuffer);
            const files = Object.keys(innerZip.files);

            // Check if we should merge overlays
            const mergeOverlays = document.getElementById(
              "mergeOverlaysCheckbox"
            ).checked;
            const deferVideoOverlays = document.getElementById(
              "deferVideoOverlaysCheckbox"
            ).checked;
            const isImage = metadata.media_type === "Image";
            const isVideo = metadata.media_type === "Video";
            const hasOverlay = files.some((f) =>
              f.toLowerCase().includes("overlay")
            );

            // Check if we should defer video overlay processing
            const shouldDeferVideo = isVideo && mergeOverlays && deferVideoOverlays && hasOverlay;

            // Try to merge if checkbox is checked and has overlay
            if (mergeOverlays && hasOverlay && files.length === 2 && !shouldDeferVideo) {
              if (isImage) {
                try {
                  // Get main and overlay files
                  let mainData = null;
                  let overlayData = null;
                  let mainName = null;
                  let overlayName = null;

                  for (const filename of files) {
                    const fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    if (filename.toLowerCase().includes("overlay")) {
                      overlayData = fileData;
                      overlayName = filename;
                    } else {
                      mainData = fileData;
                      mainName = filename;
                    }
                  }

                  if (mainData && overlayData) {
                    // Merge the images
                    let mergedData = await mergeImageOverlay(
                      mainData,
                      overlayData
                    );

                    // Add EXIF metadata to merged image
                    mergedData = await addExifMetadata(
                      mergedData,
                      metadata.date,
                      metadata.latitude,
                      metadata.longitude
                    );

                    const filename = generateFilename(metadata.date, extension, useTimestampFilenames, fileNum);

                    // Add to ZIP with original date
                    const fileDate = parseSnapchatDate(metadata.date);
                    zip.file(filename, mergedData, { date: fileDate });
                    metadata.files.push({
                      path: filename,
                      size: mergedData.byteLength,
                      type: "merged",
                    });
                    addLog(
                      `  Merged overlay: ${filename} (${formatBytes(
                        mergedData.byteLength
                      )})`,
                      "success"
                    );
                  } else {
                    throw new Error("Missing main or overlay file");
                  }
                } catch (error) {
                  // Normalize error
                  let errorMsg = "";
                  try {
                    errorMsg = error && (error.message || String(error) || JSON.stringify(error));
                  } catch (e) {
                    errorMsg = "Unknown error";
                  }
                  addLog(
                    `  Warning: Failed to merge overlay (${errorMsg}), saving separately`,
                    "info"
                  );
                  console.error("Failed to merge overlay", error);
                  // Debug details
                  try {
                    addLog(`    overlay name: ${overlayName || 'unknown'}`, "info");
                    const overlayBytes = overlayData ? new Uint8Array(overlayData).length : 0;
                    addLog(`    overlay size: ${overlayBytes} bytes`, "info");
                    const detected = overlayData ? detectFileExtension(new Uint8Array(overlayData)) : null;
                    addLog(`    overlay detected ext: ${detected || 'unknown'}`, "info");
                  } catch (debugError) {
                    addLog(`    Debug info failed: ${(debugError && debugError.message) || String(debugError)}`, "info");
                  }
                  if (error && error.stack) addLog(`    Stack: ${error.stack}`, "info");
                  // Fall back to saving separately
                  const fileDate = parseSnapchatDate(metadata.date);
                  for (const filename of files) {
                    let fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    const isOverlay = filename
                      .toLowerCase()
                      .includes("overlay");
                    // Preserve original extension if present in inner filename
                    let origExt = filename.includes('.') ? filename.substring(filename.lastIndexOf('.')) : null;
                    if (!origExt) {
                      const detected = detectFileExtension(new Uint8Array(fileData));
                      origExt = detected || extension;
                    }
                    // Generate base filename and add -main/-overlay suffix
                    const baseFilename = generateFilename(metadata.date, origExt, useTimestampFilenames, fileNum);
                    const baseNameNoExt = baseFilename.substring(0, baseFilename.lastIndexOf('.'));
                    const newFilename = isOverlay
                      ? `${baseNameNoExt}-overlay${origExt}`
                      : `${baseNameNoExt}-main${origExt}`;

                    // Add EXIF metadata to images
                    if (metadata.media_type === "Image") {
                      fileData = await addExifMetadata(
                        fileData,
                        metadata.date,
                        metadata.latitude,
                        metadata.longitude
                      );
                    }

                    zip.file(newFilename, fileData, { date: fileDate });
                    addLog(`    Saved extracted file: ${newFilename} (${formatBytes(fileData.byteLength)})`, "info");
                    metadata.files.push({
                      path: newFilename,
                      size: fileData.byteLength,
                      type: isOverlay ? "overlay" : "main",
                    });
                  }
                  addLog(
                    `  Extracted ${files.length} files from ZIP`,
                    "success"
                  );
                }
              } else if (isVideo) {
                try {
                  addLog(
                    `  Merging video overlay (please wait, this may take a minute)...`,
                    "info"
                  );

                  // Get main and overlay files (preserve original filenames/extensions)
                  let mainData = null;
                  let overlayData = null;
                  let mainName = null;
                  let overlayName = null;

                  for (const filename of files) {
                    const fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    if (filename.toLowerCase().includes("overlay")) {
                      overlayData = fileData;
                      overlayName = filename;
                    } else {
                      mainData = fileData;
                      mainName = filename;
                    }
                  }

                  if (mainData && overlayData) {
                    // Determine overlay extension and whether it's an image
                    let overlayExt = overlayName && overlayName.includes('.')
                      ? overlayName.substring(overlayName.lastIndexOf('.'))
                      : null;
                    // Try to detect from data if no extension or ambiguous
                    const detectedOverlayExt = detectFileExtension(new Uint8Array(overlayData));
                    if (detectedOverlayExt) overlayExt = detectedOverlayExt;
                    if (!overlayExt) overlayExt = '.mp4';
                    const overlayExtNoDot = overlayExt.replace('.', '').toLowerCase();
                    // Treat WebP and GIF as video to preserve animation frames
                    // Static images: PNG, JPG, JPEG only
                    const overlayIsImage = ['png', 'jpg', 'jpeg'].includes(overlayExtNoDot);

                    // Merge videos using FFmpeg.wasm (supports image overlay)
                    let mergedData = await mergeVideoOverlay(
                      mainData,
                      overlayData,
                      (progress) => {
                        addLog(
                          `    Video merge progress: ${progress}%`,
                          "info"
                        );
                      },
                      overlayIsImage,
                      overlayExt
                    );

                    // Add GPS and timestamp metadata to merged video
                    mergedData = await addVideoMetadata(
                      mergedData,
                      metadata.date,
                      metadata.latitude,
                      metadata.longitude
                    );

                    const filename = generateFilename(metadata.date, extension, useTimestampFilenames, fileNum);

                    // Add to ZIP with original date
                    // Store videos uncompressed to prevent browser playback issues
                    const fileDate = parseSnapchatDate(metadata.date);
                    zip.file(filename, mergedData, { date: fileDate, compression: "STORE" });
                    metadata.files.push({
                      path: filename,
                      size: mergedData.byteLength,
                      type: "merged",
                    });
                    addLog(
                      `  Merged video: ${filename} (${formatBytes(
                        mergedData.byteLength
                      )})`,
                      "success"
                    );

                    // Mark that we merged a video overlay immediately (not deferred)
                    mergedVideoImmediately = true;

                    // Check memory after video processing
                    checkMemoryUsage();
                  } else {
                    throw new Error("Missing main or overlay video file");
                  }
                } catch (error) {
                  // Normalize the error into a readable message
                  let errorMsg = "";
                  try {
                    errorMsg = error && (error.message || String(error) || JSON.stringify(error));
                  } catch (e) {
                    errorMsg = "Unknown error";
                  }

                  addLog(
                    `  Warning: Failed to merge video overlay (${errorMsg}), saving separately`,
                    "info"
                  );
                  console.error("Failed to merge video overlay", error);

                  // Additional debug information
                  try {
                    const mainBytes = mainData ? new Uint8Array(mainData).length : 0;
                    const overlayBytes = overlayData ? new Uint8Array(overlayData).length : 0;
                    addLog(`    main size: ${mainBytes} bytes`, "info");
                    addLog(`    overlay size: ${overlayBytes} bytes`, "info");

                    // Derive overlay ext and detection info for debugging
                    let overlayDetectedExt = overlayName && overlayName.includes('.') ? overlayName.substring(overlayName.lastIndexOf('.')) : null;
                    const detectedOverlayFromBytes = overlayData ? detectFileExtension(new Uint8Array(overlayData)) : null;
                    if (detectedOverlayFromBytes) overlayDetectedExt = detectedOverlayFromBytes;
                    overlayDetectedExt = overlayDetectedExt || 'unknown';
                    const overlayIsImageDetected = ['.png', '.jpg', '.jpeg', '.webp', '.gif'].includes((overlayDetectedExt || '').replace('.', '').toLowerCase());
                    addLog(`    overlay name: ${overlayName || 'unknown'}`, "info");
                    addLog(`    overlay detected ext: ${overlayDetectedExt} (image? ${overlayIsImageDetected})`, "info");
                  } catch (debugError) {
                    addLog(`    Debug info collection failed: ${(debugError && debugError.message) || String(debugError)}`, "info");
                  }

                  // Dump stack if available
                  if (error && error.stack) {
                    addLog(`    Stack: ${error.stack}`, "info");
                  }
                  // Fall back to saving separately
                  const fileDate = parseSnapchatDate(metadata.date);
                  for (const filename of files) {
                    let fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    const isOverlay = filename
                      .toLowerCase()
                      .includes("overlay");
                    let origExt = filename.includes('.') ? filename.substring(filename.lastIndexOf('.')) : null;
                    if (!origExt) {
                      const detected = detectFileExtension(new Uint8Array(fileData));
                      origExt = detected || extension;
                    }
                    // Generate base filename and add -main/-overlay suffix
                    const baseFilename = generateFilename(metadata.date, origExt, useTimestampFilenames, fileNum);
                    const baseNameNoExt = baseFilename.substring(0, baseFilename.lastIndexOf('.'));
                    const newFilename = isOverlay
                      ? `${baseNameNoExt}-overlay${origExt}`
                      : `${baseNameNoExt}-main${origExt}`;

                    // Add GPS and timestamp metadata to main video file (not overlay)
                    if (metadata.media_type === "Video" && !isOverlay) {
                      fileData = await addVideoMetadata(
                        fileData,
                        metadata.date,
                        metadata.latitude,
                        metadata.longitude
                      );
                    }

                    // Store videos uncompressed (this is video merge fallback path)
                    zip.file(newFilename, fileData, { date: fileDate, compression: "STORE" });
                    metadata.files.push({
                      path: newFilename,
                      size: fileData.byteLength,
                      type: isOverlay ? "overlay" : "main",
                    });
                  }
                  addLog(
                    `  Extracted ${files.length} video files from ZIP`,
                    "success"
                  );
                }
              }
            } else {
              // Save files separately (not merging, no overlay, or single file)
              const fileDate = parseSnapchatDate(metadata.date);

              // Track deferred video overlays
              if (shouldDeferVideo) {
                addLog(`  Deferring video overlay merge until end`, "info");
              }

              for (const filename of files) {
                    let fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    const isOverlay = filename.toLowerCase().includes("overlay");
                    // Preserve original extension from the inner filename if present
                    let origExt = filename.includes('.') ? filename.substring(filename.lastIndexOf('.')) : null;
                    if (!origExt) {
                      const detected = detectFileExtension(new Uint8Array(fileData));
                      origExt = detected || extension;
                    }
                    // Generate base filename and add -main/-overlay suffix
                    const baseFilename = generateFilename(metadata.date, origExt, useTimestampFilenames, fileNum);
                    const baseNameNoExt = baseFilename.substring(0, baseFilename.lastIndexOf('.'));
                    const newFilename = isOverlay
                      ? `${baseNameNoExt}-overlay${origExt}`
                      : `${baseNameNoExt}-main${origExt}`;

                    // Add EXIF metadata to images
                    if (metadata.media_type === "Image") {
                      fileData = await addExifMetadata(
                        fileData,
                        metadata.date,
                        metadata.latitude,
                        metadata.longitude
                      );
                    }

                    // Add GPS and timestamp metadata to main video file (not overlay)
                    if (metadata.media_type === "Video" && !isOverlay) {
                      fileData = await addVideoMetadata(
                        fileData,
                        metadata.date,
                        metadata.latitude,
                        metadata.longitude
                      );
                    }

                    // Store videos uncompressed to prevent browser playback issues
                    // CRITICAL: Videos MUST use compression: "STORE" (no compression)
                    //
                    // Why no compression for videos?
                    // - MP4/video files are ALREADY compressed (H.264, H.265, etc.)
                    // - ZIP DEFLATE compression on already-compressed data provides minimal benefit
                    // - Some browser ZIP decoders BREAK when re-compressing video streams
                    // - Symptoms: Video won't play, shows errors, or corrupted frames
                    // - STORE mode = no compression = direct copy into ZIP (safe, fast)
                    //
                    // Images can use DEFLATE compression (default) without issues
                    const zipOptions = { date: fileDate };
                    if (metadata.media_type === "Video") {
                      zipOptions.compression = "STORE";  // No compression for videos
                    }

                    zip.file(newFilename, fileData, zipOptions);
                    metadata.files.push({
                      path: newFilename,
                      size: fileData.byteLength,
                      type: isOverlay ? "overlay" : "main",
                    });
                  }
              addLog(`  Extracted ${files.length} files from ZIP`, "success");

              // Add to deferred processing queue
              if (shouldDeferVideo) {
                deferredVideoOverlays.push({
                  metadata: metadata,
                  fileNum: fileNum,
                  files: files,
                  innerZip: innerZip
                });
              }
            }
          } else {
            // Regular file
            let fileData = arrayBuffer;
            const filename = generateFilename(metadata.date, extension, useTimestampFilenames, fileNum);
            const fileDate = parseSnapchatDate(metadata.date);

            // Add EXIF metadata to images
            if (metadata.media_type === "Image") {
              fileData = await addExifMetadata(
                fileData,
                metadata.date,
                metadata.latitude,
                metadata.longitude
              );
            }

            // Add GPS and timestamp metadata to videos
            if (metadata.media_type === "Video") {
              fileData = await addVideoMetadata(
                fileData,
                metadata.date,
                metadata.latitude,
                metadata.longitude
              );
            }

            // Store videos uncompressed to prevent browser playback issues
            // DEFLATE compression on already-compressed video can break browser decoders
            const zipOptions = { date: fileDate };
            if (metadata.media_type === "Video") {
              zipOptions.compression = "STORE";
            }

            zip.file(filename, fileData, zipOptions);
            metadata.files.push({
              path: filename,
              size: fileData.byteLength,  // Use fileData size (after metadata added)
              type: "single",
            });
            addLog(
              `  Downloaded: ${filename} (${formatBytes(
                fileData.byteLength
              )})`,
              "success"
            );
          }

        // Mark as successful
        metadata.status = "success";
        delete metadata.error; // Remove any previous error
      } catch (error) {
        addLog(`  ERROR: ${error.message}`, "error");
        metadata.status = "failed";
        metadata.error = error.message;
      }

      // Return whether we merged a video overlay immediately
      return { mergedVideoImmediately };
    }

    function formatBytes(bytes) {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return (
        Math.round((bytes / Math.pow(k, i)) * 100) / 100 + " " + sizes[i]
      );
    }
  </script>
</body>

</html>